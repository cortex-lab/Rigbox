
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Experiment definition inputs</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-03-13"><meta name="DC.source" content="expDef_inputs.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Experiment definition inputs</h1><!--introduction--><p>This guide goes through all of the inputs to an expDef function and provides a few examples of how to work with the.  Below is the function signature of an expDef:</p><pre class="language-matlab"><span class="keyword">function</span> expDefFn(t, events, parameters, vs, inputs, outputs, audio)
</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Time</a></li><li><a href="#2">Events</a></li><li><a href="#3">Special events</a></li><li><a href="#4">expStart</a></li><li><a href="#5">newTrial</a></li><li><a href="#6">trialNum</a></li><li><a href="#7">endTrial</a></li><li><a href="#8">repeatNum</a></li><li><a href="#9">expStop</a></li><li><a href="#14">Logging your own events</a></li><li><a href="#15">Parameter defaults</a></li><li><a href="#16">Visual stimuli</a></li><li><a href="#17">Inputs</a></li><li><a href="#18">Outputs</a></li><li><a href="#19">Audio</a></li><li><a href="#24">Summary</a></li><li><a href="#25">Etc.</a></li></ul></div><h2 id="1">Time</h2><p>The first input is a clock signal whose value is the number of seconds from the start of the experiment.  It updates its value on every iteration of the main experiment loop.  The value of t is always positive.  It is the first signal in an experiment to update.  If there is an experiment pre-delay, the time signal will still update before the expStart event signal and therefore any signals that depend only on the time signal will also update early (remember signals update when their inputs update so long as their inputs have a value).</p><h2 id="2">Events</h2><p>The second input to your expDef is the events signal.  The events signal is subscriptable, much like a struct, and contains signals related to the experiment trial structure.  All signals that are part of the events signal have their values logged, tampstamped and saved at the end of the experiment.  You can assign any number of signals to the events signal to record their values in the block file.</p><p>For more info on the block file, see the <a href="./block_files.html">block files guide</a>.  You can inspect the block file data when debugging an expDef in the test GUI (see <a href="./using_test_gui.html#5">this guide</a>).</p><h2 id="3">Special events</h2><p>Below are a list of preset event signals that you can use in your expDef.</p><h2 id="4">expStart</h2><p>This updates once and only once at the start of the experiment.  Its value is the expRef (a char).  Thus if you want to use it to trigger something, map it to a constant first:</p><pre class="codeinput">started = events.expStart.map(true);
w0 = inputs.wheel.at(started);
</pre><h2 id="5">newTrial</h2><p>This updates to true each time there is a new trial (i.e. after endTrial updates.  Each time newTrial updates, the parameters update too.  Most of the time in MATLAB values are quietly typecast for you.  For instance <tt>true + true == 2</tt>.  Signals are no different.  Sometimes functions complain so be sure to typecast if you're using it as a number:</p><pre class="codeinput">side = events.newTrial.map(@(k) randsample([-1 1], int32(k))); <span class="comment">% Conveted to an int</span>
</pre><h2 id="6">trialNum</h2><p>This updates at the start of each new trial (i.e. after endTrial updates) and its value is the current trial number (double).  Behind the scenes, trialNum is really just this:</p><pre class="codeinput">events.trialNum = events.newTrial.scan(@plus, 0);
</pre><h2 id="7">endTrial</h2><p>The endTrial event is the only signal that must be defined in your expDef.  Each time endTrial updates, the trial ends and parameters, newTrial, trialNum and repeatNum all update.  There is no significant delay between endTrial and newTrial, so any 'inter-trial' delays must actually occur before or after and endTrial and newTrial.</p><p>Below is the absolute minimum required for an expDef:</p><pre class="language-matlab"><span class="keyword">function</span> expDefFn(t, events, varargin)
<span class="comment">% End each trial after 5 seconds</span>
events.endTrial = events.newTrial.delay(5);
<span class="keyword">end</span>
</pre><p>The value of the endTrial can be anything, however the Signals Experiment Framework checks the value and determines whether to repeat the trial conditional parameters.  If the value of endTrial == true (i.e. is a non-zero value) then the trial conditions are repeated the following trial.</p><p>The way you define endTrial allows you to finely control the trial structure.  Here are some examples:</p><div><ul><li>Fully randomized trial parameters</li><li>Hard anti-biasing where trial parameters are repeated until the correct response is given</li><li>Soft anti-biasing where the liklihood of repeating a parameter depends on performance</li><li>Trial conditions occur in a given order and all conditions repeated some number of times</li><li>Trial conditions randomized but repeated sequentially a given number of times</li></ul></div><p>In the following example we define a passive experiment where the orientation varies across trials.  Each orientation is shown twice in a row:</p><pre class="language-matlab"><span class="keyword">function</span> driftingGrating(t, evts, pars, stimuli, varargin)
<span class="comment">% DRIFTINGGRATING A drifting grating with a different orientation per trial</span>
<span class="comment">%   Displays a 3Hz drifting grating at a given orientation.  The</span>
<span class="comment">%   orientation is repeated some number of times in a row and the order in</span>
<span class="comment">%   which the orientations are shown is randomized.</span>
</pre><pre class="language-matlab"><span class="comment">% Define the visual stimulus</span>
grating = vis.grating(t); <span class="comment">% we want a gabor grating patch</span>
grating.phase = 2*pi*t*3; <span class="comment">% with its phase cycling at 3Hz</span>
<span class="comment">% stimOff occurs some user defined seconds after new trial starts</span>
stimOff = evts.newTrial.delay(pars.stimDuration);
<span class="comment">% stimulus visible between trial onset &amp; stimOff</span>
grating.orientation = pars.orientation;
grating.show = evts.newTrial.to(stimOff);
</pre><pre class="language-matlab"><span class="comment">% Trial logic</span>
<span class="comment">% Move on to next orientation after the sequential repeats</span>
nextCondition = evts.repeatNum == pars.sequentialRepeats;
<span class="comment">% next trial should start 1s after stimOff</span>
evts.endTrial = stimOff.delay(1).then(nextCondition);
</pre><pre class="language-matlab"><span class="comment">% Add stimulus to renderer</span>
stimuli.grating = grating;
</pre><pre class="language-matlab"><span class="keyword">try</span>
  pars.stimDuration = 5; <span class="comment">% seconds</span>
  nOrientations = 3; <span class="comment">% Number of trial conditions</span>
  pars.orientation = linspace(0, 270, nOrientations); <span class="comment">% Orientations to use</span>
  pars.sequentialRepeats = 2; <span class="comment">% Show each orientation twice in a row</span>
<span class="keyword">catch</span>
<span class="keyword">end</span>
</pre><p>For detailed examples see the <a href="./Parameters.html">Parameters guide</a>.</p><h2 id="8">repeatNum</h2><p>The repeatNum event simply counts the number of times in a row the endTrial event signal was 0 or false.  When endTrial updates to a non-zero value, repeatNum resets to 1.  repeatNum updates at the same times as newTrial and trialNum.</p><h2 id="9">expStop</h2><p>When the expStop signal updates, the experiment ends.  This can be used to trigger cleanup routines or to define when the experiment ends based on experiment parameters. Experiments will end automatically if all trial conditions have occured (defined by the numRepeats parameter), if the quit key is pressed on the stimulus computer, or if the 'End' or 'Abort' button is pressed in mc.</p><p>Example 1 - Referencing expStop</p><pre class="codeinput"><span class="comment">% Open a text file at the beginning of an experiment</span>
fid = events.expStart.map(@(~) fopen(<span class="string">'expData.txt'</span>, <span class="string">'r'</span>));
<span class="comment">% On each new trial read the next line from the file</span>
tline = events.newTrial.then(fid).map(@fgetl);
<span class="comment">% When the experiment stops, close the file</span>
events.expStop.then(fid).map(@fclose);
</pre><p><b>NB</b>: When the post-delay is set to zero the cleanup routine executes immediately after expStop updates so at some point the updates in the network will be interrupted.  If you trigger a slow function with expStop then ensure there is a reasonable post-delay to ensure the network has time to finish propagation.</p><p>Example 2 - Assigning to expStop</p><pre class="codeinput"><span class="comment">% End the experiment after a set amount of time</span>
expLength = p.expLengthMin * 60; <span class="comment">% convert to seconds</span>
events.expStop = events.expStart.map(true).delay(expLength);
</pre><p><b>NB</b>: The expStop event can have any value and is of course saved, thus you can use it to note how the experiment ended, further, any value will trigger the experiment to end, so make sure it only updates once, at the intended time.</p><p>Example 3 - End experiment based on performance and reaction time</p><pre class="codeinput"><span class="comment">% Response time = duration (seconds) between new trial and response</span>
rt = t.at(stimOn).map2(t, @(a,b)diff([a,b])).at(response);
<span class="comment">% The median response time over the last 20 trials</span>
windowedRT = rt.buffer(20).map(@median);
<span class="comment">% The median response time over all trials</span>
baselineRT = rt.bufferUpTo(1000).map(@median);
<span class="comment">% tooSlow is true when windowed rt is x times longer than median rt for the</span>
<span class="comment">% session, where x is the rtCriterion</span>
tooSlow = windowedRT &gt; baselineRT * p.rtCriterion;

<span class="comment">% A rolloing buffer of performance (proportion of last 20 trials that were</span>
<span class="comment">% correct) - this includes repeat on incorrect trials</span>
windowedPerf = hit.buffer(20);
windowedPerf = sum(windowedPerf) / numel(windowedPerf);
<span class="comment">% Proportion of all trials that were correct</span>
baselinePerf = hit.bufferUpTo(1000).map(@(a)sum(a)/length(a));

<span class="comment">% True when there is an x% decrease in performance over the last 20 trials</span>
<span class="comment">% compared to the session average, where x is pctPerfDecrease</span>
performanceChange = (baselinePerf - windowedPerf) / baselinePerf;
poorPerformance = performanceChange &gt; p.pctPerfDecrease / 100;

<span class="comment">% The subject is identified as disengaged from the task when the subject is</span>
<span class="comment">% either too slow or exhibits a significant drop in performance.</span>
maxLength  = events.expStart.map(1).delay(45*60); <span class="comment">% Session length: 45 min</span>
finished = indexOfFirst(tooSlow, performanceChange, maxLength);

<span class="comment">% The session is finished when either the session has been running for 45</span>
<span class="comment">% min, or when the subject is disengaged.  The 'finish' signal only updates</span>
<span class="comment">% when one of the three inputs updates to true.</span>
endReason = finished.selectFrom(<span class="string">'long rt'</span>, <span class="string">'poor performance'</span>, <span class="string">'max session length'</span>);
events.expStop = endReason;
</pre><h2 id="14">Logging your own events</h2><p>You can assign any number of your own signal to the events structure if you want their values and timestamps saved.  Events are always horizontally concatenated, so if you have a row vector and want to store its history, transpose it when assigning to the events registry and you'll get a matrix out:</p><pre>   events = sig.Registry(); % Similar to the events input
   S = string(strsplit(which('addRigboxPaths'), filesep)); % A string array
   events.str = sig.test.sequence(S, 0.2); % str updates with a new string every 200ms
   events.char = events.str.map(@char); % char takes values of str but as a char
   vec = events.str.map(@(~) rand(1,3)); % vec updates with a 1x3 array each time str updates
   events.mat = vec.'; % Transpose vector when saving to build up matrix</pre><pre>   data = logs(events) % the events structure as seen in a block file</pre><pre>   data =</pre><pre>     struct with fields:</pre><pre>        strValues: ["C:"    "Users"    "User"    "Documents"    "Github"    "rigbox"    "addRigboxPaths.m"]
         strTimes: [1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06]
       charValues: 'C:UsersUserDocumentsGithubrigboxaddRigboxPaths.m'
        charTimes: [1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06]
        matValues: [3&times;7 double]
         matTimes: [1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06]</pre><h2 id="15">Parameter defaults</h2><p>You can define defaults for your parameters at the end of your expDef by assigning values to the parameters referenced in the experiment.</p><p>Defining parameter defaults is useful because changing parameter type is not possible in the ParamEditor.  Without defining defaults all parameters are empty doubles.</p><p>Parameters can be either 'global', i.e. have the same value each trial, or 'conditional', meaning their values can change each trial.  For more information about Experiment Parameters, see the <a href="./Parameters.html">Parameters guide</a>.</p><p>Trial conditional parameters have more than one column, where each column is a condition may be drawn on any given trial.  All trial condition parameters must have the same number of columns.  Parameters can be converted between global and conditional later on in the Parameter Editor.  The only exception to this rule is for parameters that are chars.  These are considered a single element.  To make them trial conditions, use a cellstr or string instead.</p><p>Below is an example of some parameter defaults and how they appear in the Parameter Editor:</p><pre class="language-matlab"><span class="keyword">function</span> expDefFn(t, events, p, varargin)
</pre><pre class="language-matlab"><span class="keyword">...</span>
</pre><pre class="language-matlab"><span class="keyword">try</span>
  <span class="comment">%%%</span>
  <span class="comment">% Global parameters (Number of colmns == 1)</span>
  <span class="comment">%%%</span>
  p.globalString = [<span class="string">"One"</span>; <span class="string">"Two"</span>];
  p.globalVec = (1:5)'; <span class="comment">% Transposed to column vector</span>
  p.globalBool = true;
  p.globalChar = <span class="string">'hello'</span>;
  <span class="comment">%%%</span>
  <span class="comment">% Trial condition parameters</span>
  <span class="comment">%%%</span>
  p.condDouble = 1:3;
  p.condVec = magic(3); <span class="comment">% parameter will be a [1x3] array</span>
  p.condString = [[<span class="string">"A"</span>; <span class="string">"B"</span>], [<span class="string">"a"</span>; <span class="string">"b"</span>], [<span class="string">"alpha"</span>; <span class="string">"beta"</span>]];
  p.condChar = {<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>};
<span class="keyword">catch</span>
<span class="keyword">end</span>
</pre><p><img vspace="5" hspace="5" src="./images/inferParameters.png" alt=""> </p><p>Note that the cellstr is a special exception where the parameter signal will update with a char, not cell.  It's also important to note that although vector parameters are [Nx1], the parameter signal will take the value of [1xN] (a row vector).  You can transpose the parameters in your expDef:</p><pre class="language-matlab"><span class="keyword">function</span> expDefFn(t, events, p, varargin)
  colVec = p.vec.';
  <span class="keyword">...</span>
</pre><p>numRepeats is a special parameter that does not need defining in your expDef.  By default there are 1000 trials in total.  You can change the number in the Parameter Editor.</p><h2 id="16">Visual stimuli</h2><p>The fourth input is a special object for dispatching visual stimuli to the renderer.  Visual stimuli are defined in the expDef and when assigned to the visual stimulus object, their textures are preloaded.  For details and examples of creating stimuli, see the <a href="./visual_stimuli.html">visual stimuli guide</a>.</p><h2 id="17">Inputs</h2><p>The inputs signal is a subscriptable signal containing all configured input devices.  Currently there are only three possible input devices:</p><div><ol><li>inputs.wheel - the rotary encoder device.  This can actually be any DAQ device, whatever is set as the 'mouseInput' field of the rig object (see <a href="./hardware_config.html">hardware config guide</a>).  The values of 'wheel' are in samples, and the device is zeroed during experiment initialization.  This input updates on every iteration of the main experiment loop, even if the wheel is not moving.</li><li>inputs.lickDetector - values logged via the device in the rig's 'lickDetector' field.  This input updates on every iteration of the main experiment loop.</li><li>inputs.keyboard - updates each time a keyboard key is pressed.  Note that the keyboard input's value can be more than one charecter, particularly if two keys are pressed at once.  This input only updates when a key is pressed.</li></ol></div><p>There are two other signals that are derived from 'wheel'.</p><div><ol><li>inputs.wheelMM - the values of wheel but in mm linear displacement units.</li><li>inputs.wheelDeg - the values of wheel but in degrees.  Note the values do not wrap around at 360.</li></ol></div><p>The values of these signals depend on the 'EncoderResolution' and 'WheelDiameter' properties of the mouseInput device. For details on the wheel units, see the <a href="./wheel_units.html">wheel analysis guide</a>.  Unlike the raw wheel input, these two signals only update when their values change (i.e. when the wheel is moved).</p><p>Much like the time signal, the input signals can update before the expStart and newTrial events, particularly is there is an experiment pre-delay.  Any dependent signal may therefore also update before expStart.  You can ignore all samples before expStart with the following line:</p><pre class="language-matlab"><span class="keyword">function</span> expDefFn(t, events, parameters, vs, inputs, outputs, audio)
  inputs = inputs.keepWhen(events.expStart.map(true));
  <span class="keyword">...</span>
</pre><p>As mentioned the wheel input will constantly update, regardless of whether the wheel is moving.  The <tt>skipRepeats</tt> method will return a signal that only updates when the value changes:</p><pre>   wheel = inputs.wheel.skipRepeats;</pre><p>The inputs are all saved in the hardware file in the same format as the events stucture.</p><h2 id="18">Outputs</h2><p>The name of each signal in the outputs of your experiment definition file should match the channel names set in your hardware file (see the <a href="./hardware_config.html">hardware config guide</a>), thus if in my rig hardware file <tt>daqController.ChannelNames = {'rewardValve', 'TTL', 'motor'}</tt> then my signals experiment deifinition file may look something like this:</p><pre class="language-matlab"><span class="keyword">function</span> rwdWorld(t, evts, p, vs, in, out, ~)
  rewardOn = evts.newTrial.delay(2); <span class="comment">% trigger reward 2 seconds after trial start</span>
  laserStart = rewardStart.delay(1); <span class="comment">% trigger laser 1 second after the reward</span>
</pre><pre>   reward = p.rewardSize.at(rewardOn); % reward size to output
   TTL = p.pulseSize.at(laserStart); % laser pulse size to output</pre><pre>   out.reward = reward; % output to the rewardValve channel
   out.TTL = TTL; % output signal to 'TTL' channel
   ...</pre><p>NB: out.reward is a special case and will output to the 'rewardValve' channel. This should always be the first channel in the list.</p><h2 id="19">Audio</h2><p>The final input to the expDef is an audio object.  As with the outputs object, the audio object can be assigned samples for sending to the audio driver.  The fieldname used to assign the samples corresponds to which audio device to send the samples to.  Assigning to the 'default' field will cause the samples to be played through the system's default device (unless this is changed in the rig's hardware file).</p><p>The audio devices can be queried in the following manner, where 'default' is the name of the device.  A struct of audio device information is returned.  For a list of fields, see PsychPortAudio('GetDevices').</p><pre class="codeinput">audioDevice = audio.Devices(<span class="string">'default'</span>);
nChannels = audioDevice.NrOutputChannels;
sampleRate = audioDevice.DefaultSampleRate;
</pre><p>These channels and sample rate can be used to generate the correct samples.  The below example shows how to create a sine wave tone at a particular frequency.  The function <tt>aud.pureTone</tt> returns samples given a set of parameters.</p><pre class="codeinput">frequency = 15000; <span class="comment">% Hz</span>
duration = 1; <span class="comment">% seconds</span>
rampDuration = 0.02; <span class="comment">% seconds</span>

samples = aud.pureTone(<span class="keyword">...</span>
  frequency, duration, sampleRate, rampDuration, nChannels);
</pre><p>The samples can be send to the audio driver at a given time using signals</p><pre class="codeinput"><span class="comment">% At the time of 'newTrial', send samples to audio device</span>
audio.default = events.newTrial.map(samples);
</pre><p>The samples can be generated on the fly using <tt>mapn</tt>.  In this example, each time the the tone amplitude and frequency parameters update, the samples are recalculated</p><pre class="codeinput">toneSamples = mapn(<span class="keyword">...</span>
  p.toneFrequency, <span class="keyword">...</span><span class="comment"> % frequency</span>
  0.1, sampleRate,<span class="keyword">...</span><span class="comment"> % duration and sample rate</span>
  0.02, nChannels, <span class="keyword">...</span><span class="comment"> % ramp and number of channels</span>
  @aud.pureTone);
audio.default = events.newTrial.then(p.toneAmplitude * samples);
</pre><p>The below code will produce a list of available device names that can be referenced during the experiment:</p><pre class="codeinput">rig = hw.devices;
availiable_devs = {rig.audioDevices.DeviceName}'
</pre><h2 id="24">Summary</h2><div><ol><li>the time signal, t, always updates before all other signals.</li><li>events.expStart updates once and only once during an experiment.</li><li>All parameter signals update simultaneously every trial.  If they are global parameters, they update with the same value each time.</li><li>events.expStop updates once and only once at the end of the experiment.  If you define it in your expDef, when it takes a value the experiment  will end.</li><li>All signals assigned to the events subscriptable signal will be logged and saved in your block file.  You will not be able to recover the values or update times of signals that aren't part of the inputs, parameters or events signals.</li><li>When events.endTrial updates, the trial ends.  If its value is non-zero / true, the next trial condition is selected and events.repeatNum resets to 1.  If its value is 0 / false, the exact same parameters are repeated the following trial, and events.repeatNum will increase by 1.</li><li>The only signal that must be defined in an expDef is the events.endTrial signal.</li></ol></div><h2 id="25">Etc.</h2><p>Author: Miles Wells</p><p>v0.0.2</p><p>Next section <a href="./visual_stimuli.html">Creating stimuli</a>.</p><p>See also <a href="./using_signals.html">Using Signals</a>.</p><pre class="codeinput"><span class="comment">%#ok&lt;*NOPTS&gt;</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Experiment definition inputs
% This guide goes through all of the inputs to an expDef function and
% provides a few examples of how to work with the.  Below is the function
% signature of an expDef:
%
%   function expDefFn(t, events, parameters, vs, inputs, outputs, audio)
%

%% Time
% The first input is a clock signal whose value is the number of seconds
% from the start of the experiment.  It updates its value on every
% iteration of the main experiment loop.  The value of t is always
% positive.  It is the first signal in an experiment to update.  If there
% is an experiment pre-delay, the time signal will still update before the
% expStart event signal and therefore any signals that depend only on the
% time signal will also update early (remember signals update when their
% inputs update so long as their inputs have a value).

%% Events
% The second input to your expDef is the events signal.  The events signal
% is subscriptable, much like a struct, and contains signals related to the
% experiment trial structure.  All signals that are part of the events
% signal have their values logged, tampstamped and saved at the end of the
% experiment.  You can assign any number of signals to the events signal to
% record their values in the block file.
%
% For more info on the block file, see the <./block_files.html block files
% guide>.  You can inspect the block file data when debugging an expDef in
% the test GUI (see <./using_test_gui.html#5 this guide>).
%
%% Special events
% Below are a list of preset event signals that you can use in your expDef.
%
%%% expStart
% This updates once and only once at the start of the experiment.  Its
% value is the expRef (a char).  Thus if you want to use it to trigger
% something, map it to a constant first:
started = events.expStart.map(true);
w0 = inputs.wheel.at(started);

%%% newTrial
% This updates to true each time there is a new trial (i.e. after endTrial
% updates.  Each time newTrial updates, the parameters update too.  Most of
% the time in MATLAB values are quietly typecast for you.  For instance
% |true + true == 2|.  Signals are no different.  Sometimes functions
% complain so be sure to typecast if you're using it as a number:
side = events.newTrial.map(@(k) randsample([-1 1], int32(k))); % Conveted to an int

%%% trialNum
% This updates at the start of each new trial (i.e. after endTrial updates)
% and its value is the current trial number (double).  Behind the scenes,
% trialNum is really just this:
events.trialNum = events.newTrial.scan(@plus, 0);

%%% endTrial
% The endTrial event is the only signal that must be defined in your
% expDef.  Each time endTrial updates, the trial ends and parameters,
% newTrial, trialNum and repeatNum all update.  There is no significant
% delay between endTrial and newTrial, so any 'inter-trial' delays must
% actually occur before or after and endTrial and newTrial.  
%
% Below is the absolute minimum required for an expDef:
%
%   function expDefFn(t, events, varargin)
%   % End each trial after 5 seconds
%   events.endTrial = events.newTrial.delay(5);
%   end
%
% The value of the endTrial can be anything, however the Signals Experiment
% Framework checks the value and determines whether to repeat the trial
% conditional parameters.  If the value of endTrial == true (i.e. is a
% non-zero value) then the trial conditions are repeated the following
% trial. 
%
% The way you define endTrial allows you to finely control the trial
% structure.  Here are some examples:
%
% * Fully randomized trial parameters
% * Hard anti-biasing where trial parameters are repeated until the correct
% response is given
% * Soft anti-biasing where the liklihood of repeating a parameter depends
% on performance
% * Trial conditions occur in a given order and all conditions repeated
% some number of times
% * Trial conditions randomized but repeated sequentially a given number of
% times
%
% In the following example we define a passive experiment where the
% orientation varies across trials.  Each orientation is shown twice in a
% row:
%
%   function driftingGrating(t, evts, pars, stimuli, varargin)
%   % DRIFTINGGRATING A drifting grating with a different orientation per trial
%   %   Displays a 3Hz drifting grating at a given orientation.  The
%   %   orientation is repeated some number of times in a row and the order in
%   %   which the orientations are shown is randomized.
% 
%   % Define the visual stimulus
%   grating = vis.grating(t); % we want a gabor grating patch
%   grating.phase = 2*pi*t*3; % with its phase cycling at 3Hz
%   % stimOff occurs some user defined seconds after new trial starts
%   stimOff = evts.newTrial.delay(pars.stimDuration);
%   % stimulus visible between trial onset & stimOff
%   grating.orientation = pars.orientation;
%   grating.show = evts.newTrial.to(stimOff);
% 
%   % Trial logic
%   % Move on to next orientation after the sequential repeats
%   nextCondition = evts.repeatNum == pars.sequentialRepeats;
%   % next trial should start 1s after stimOff
%   evts.endTrial = stimOff.delay(1).then(nextCondition);
% 
%   % Add stimulus to renderer
%   stimuli.grating = grating;
% 
%   try
%     pars.stimDuration = 5; % seconds
%     nOrientations = 3; % Number of trial conditions
%     pars.orientation = linspace(0, 270, nOrientations); % Orientations to use
%     pars.sequentialRepeats = 2; % Show each orientation twice in a row
%   catch
%   end
%
% For detailed examples see the <./Parameters.html Parameters guide>.
%

%%% repeatNum
% The repeatNum event simply counts the number of times in a row the
% endTrial event signal was 0 or false.  When endTrial updates to a
% non-zero value, repeatNum resets to 1.  repeatNum updates at the same
% times as newTrial and trialNum.
%

%%% expStop
% When the expStop signal updates, the experiment ends.  This can be used
% to trigger cleanup routines or to define when the experiment ends based
% on experiment parameters. Experiments will end automatically if all trial
% conditions have occured (defined by the numRepeats parameter), if the
% quit key is pressed on the stimulus computer, or if the 'End' or 'Abort'
% button is pressed in mc.  
%
% Example 1 - Referencing expStop

% Open a text file at the beginning of an experiment
fid = events.expStart.map(@(~) fopen('expData.txt', 'r'));
% On each new trial read the next line from the file
tline = events.newTrial.then(fid).map(@fgetl);
% When the experiment stops, close the file
events.expStop.then(fid).map(@fclose);

%%%
% *NB*: When the post-delay is set to zero the cleanup routine executes
% immediately after expStop updates so at some point the updates in the
% network will be interrupted.  If you trigger a slow function with expStop
% then ensure there is a reasonable post-delay to ensure the network has
% time to finish propagation.

%%%
% Example 2 - Assigning to expStop

% End the experiment after a set amount of time
expLength = p.expLengthMin * 60; % convert to seconds
events.expStop = events.expStart.map(true).delay(expLength);

%%%
% *NB*: The expStop event can have any value and is of course saved, thus
% you can use it to note how the experiment ended, further, any value will
% trigger the experiment to end, so make sure it only updates once, at the
% intended time.

%%%
% Example 3 - End experiment based on performance and reaction time

% Response time = duration (seconds) between new trial and response
rt = t.at(stimOn).map2(t, @(a,b)diff([a,b])).at(response);
% The median response time over the last 20 trials
windowedRT = rt.buffer(20).map(@median);
% The median response time over all trials
baselineRT = rt.bufferUpTo(1000).map(@median); 
% tooSlow is true when windowed rt is x times longer than median rt for the
% session, where x is the rtCriterion
tooSlow = windowedRT > baselineRT * p.rtCriterion;

% A rolloing buffer of performance (proportion of last 20 trials that were
% correct) - this includes repeat on incorrect trials
windowedPerf = hit.buffer(20);
windowedPerf = sum(windowedPerf) / numel(windowedPerf);
% Proportion of all trials that were correct
baselinePerf = hit.bufferUpTo(1000).map(@(a)sum(a)/length(a));

% True when there is an x% decrease in performance over the last 20 trials
% compared to the session average, where x is pctPerfDecrease
performanceChange = (baselinePerf - windowedPerf) / baselinePerf;
poorPerformance = performanceChange > p.pctPerfDecrease / 100;

% The subject is identified as disengaged from the task when the subject is
% either too slow or exhibits a significant drop in performance.
maxLength  = events.expStart.map(1).delay(45*60); % Session length: 45 min
finished = indexOfFirst(tooSlow, performanceChange, maxLength);

% The session is finished when either the session has been running for 45
% min, or when the subject is disengaged.  The 'finish' signal only updates
% when one of the three inputs updates to true.
endReason = finished.selectFrom('long rt', 'poor performance', 'max session length');
events.expStop = endReason;

%% Logging your own events
% You can assign any number of your own signal to the events structure if
% you want their values and timestamps saved.  Events are always
% horizontally concatenated, so if you have a row vector and want to store
% its history, transpose it when assigning to the events registry and
% you'll get a matrix out:
% 
%     events = sig.Registry(); % Similar to the events input
%     S = string(strsplit(which('addRigboxPaths'), filesep)); % A string array
%     events.str = sig.test.sequence(S, 0.2); % str updates with a new string every 200ms
%     events.char = events.str.map(@char); % char takes values of str but as a char
%     vec = events.str.map(@(~) rand(1,3)); % vec updates with a 1x3 array each time str updates
%     events.mat = vec.'; % Transpose vector when saving to build up matrix
%     
%     data = logs(events) % the events structure as seen in a block file
%
%     data = 
% 
%       struct with fields:
% 
%          strValues: ["C:"    "Users"    "User"    "Documents"    "Github"    "rigbox"    "addRigboxPaths.m"]
%           strTimes: [1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06]
%         charValues: 'C:UsersUserDocumentsGithubrigboxaddRigboxPaths.m'
%          charTimes: [1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06]
%          matValues: [3Ã—7 double]
%           matTimes: [1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06 1.6519e+06]

%% Parameter defaults
% You can define defaults for your parameters at the end of your expDef by
% assigning values to the parameters referenced in the experiment.  
%
% Defining parameter defaults is useful because changing parameter type is
% not possible in the ParamEditor.  Without defining defaults all
% parameters are empty doubles.  
%
% Parameters can be either 'global', i.e. have the same value each trial,
% or 'conditional', meaning their values can change each trial.  For more
% information about Experiment Parameters, see the <./Parameters.html
% Parameters guide>.
%
% Trial conditional parameters have more than one column, where each column
% is a condition may be drawn on any given trial.  All trial condition
% parameters must have the same number of columns.  Parameters can be
% converted between global and conditional later on in the Parameter
% Editor.  The only exception to this rule is for parameters that are
% chars.  These are considered a single element.  To make them trial
% conditions, use a cellstr or string instead.
%
% Below is an example of some parameter defaults and how they appear in the
% Parameter Editor:
%
%   function expDefFn(t, events, p, varargin)
% 
%   ...
% 
%   try
%     %%%
%     % Global parameters (Number of colmns == 1)
%     %%%
%     p.globalString = ["One"; "Two"];
%     p.globalVec = (1:5)'; % Transposed to column vector
%     p.globalBool = true;
%     p.globalChar = 'hello';
%     %%%
%     % Trial condition parameters
%     %%%
%     p.condDouble = 1:3;
%     p.condVec = magic(3); % parameter will be a [1x3] array
%     p.condString = [["A"; "B"], ["a"; "b"], ["alpha"; "beta"]];
%     p.condChar = {'foo', 'bar', 'baz'};
%   catch
%   end
%
%
% <<./images/inferParameters.png>>
% 
% Note that the cellstr is a special exception where the parameter signal
% will update with a char, not cell.  It's also important to note that
% although vector parameters are [Nx1], the parameter signal will take the
% value of [1xN] (a row vector).  You can transpose the parameters in your
% expDef:
%
%   function expDefFn(t, events, p, varargin)
%     colVec = p.vec.'; 
%     ...
%
% numRepeats is a special parameter that does not need defining in your
% expDef.  By default there are 1000 trials in total.  You can change the
% number in the Parameter Editor.

%% Visual stimuli
% The fourth input is a special object for dispatching visual stimuli to
% the renderer.  Visual stimuli are defined in the expDef and when assigned
% to the visual stimulus object, their textures are preloaded.  For details
% and examples of creating stimuli, see the <./visual_stimuli.html visual
% stimuli guide>.

%% Inputs
% The inputs signal is a subscriptable signal containing all configured
% input devices.  Currently there are only three possible input devices:
%
% # inputs.wheel - the rotary encoder device.  This can actually be any DAQ
% device, whatever is set as the 'mouseInput' field of the rig object (see
% <./hardware_config.html hardware config guide>).  The values of 'wheel'
% are in samples, and the device is zeroed during experiment
% initialization.  This input updates on every iteration of the main
% experiment loop, even if the wheel is not moving.
% # inputs.lickDetector - values logged via the device in the rig's
% 'lickDetector' field.  This input updates on every iteration of the main
% experiment loop.
% # inputs.keyboard - updates each time a keyboard key is pressed.  Note
% that the keyboard input's value can be more than one charecter,
% particularly if two keys are pressed at once.  This input only updates
% when a key is pressed.
% 
% There are two other signals that are derived from 'wheel'. 
% 
% # inputs.wheelMM - the values of wheel but in mm linear displacement
% units.
% # inputs.wheelDeg - the values of wheel but in degrees.  Note the values
% do not wrap around at 360.
%
% The values of these signals depend on the 'EncoderResolution' and
% 'WheelDiameter' properties of the mouseInput device. For details on the
% wheel units, see the <./wheel_units.html wheel analysis guide>.  Unlike
% the raw wheel input, these two signals only update when their values
% change (i.e. when the wheel is moved).
%
% Much like the time signal, the input signals can update before the
% expStart and newTrial events, particularly is there is an experiment
% pre-delay.  Any dependent signal may therefore also update before
% expStart.  You can ignore all samples before expStart with the following
% line:
%
%   function expDefFn(t, events, parameters, vs, inputs, outputs, audio)
%     inputs = inputs.keepWhen(events.expStart.map(true));
%     ...
%
% As mentioned the wheel input will constantly update, regardless of
% whether the wheel is moving.  The |skipRepeats| method will return a
% signal that only updates when the value changes:
%   
%     wheel = inputs.wheel.skipRepeats;
%
% The inputs are all saved in the hardware file in the same format as the
% events stucture.  

%% Outputs
% The name of each signal in the outputs of your experiment definition file
% should match the channel names set in your hardware file (see the
% <./hardware_config.html hardware config guide>), thus if in my rig
% hardware file |daqController.ChannelNames = {'rewardValve', 'TTL',
% 'motor'}| then my signals experiment deifinition file may look something
% like this:
% 
%   function rwdWorld(t, evts, p, vs, in, out, ~)
%     rewardOn = evts.newTrial.delay(2); % trigger reward 2 seconds after trial start
%     laserStart = rewardStart.delay(1); % trigger laser 1 second after the reward
% 
%     reward = p.rewardSize.at(rewardOn); % reward size to output
%     TTL = p.pulseSize.at(laserStart); % laser pulse size to output
% 
%     out.reward = reward; % output to the rewardValve channel
%     out.TTL = TTL; % output signal to 'TTL' channel
%     ...
%
% NB: out.reward is a special case and will output to the 'rewardValve'
% channel. This should always be the first channel in the list.

%% Audio
% The final input to the expDef is an audio object.  As with the outputs
% object, the audio object can be assigned samples for sending to the audio
% driver.  The fieldname used to assign the samples corresponds to which
% audio device to send the samples to.  Assigning to the 'default' field
% will cause the samples to be played through the system's default device
% (unless this is changed in the rig's hardware file).
%
% The audio devices can be queried in the following manner, where 'default'
% is the name of the device.  A struct of audio device information is
% returned.  For a list of fields, see PsychPortAudio('GetDevices').
audioDevice = audio.Devices('default');
nChannels = audioDevice.NrOutputChannels;
sampleRate = audioDevice.DefaultSampleRate;

%%%
% These channels and sample rate can be used to generate the correct
% samples.  The below example shows how to create a sine wave tone at a
% particular frequency.  The function |aud.pureTone| returns samples given
% a set of parameters.
frequency = 15000; % Hz
duration = 1; % seconds
rampDuration = 0.02; % seconds

samples = aud.pureTone(...
  frequency, duration, sampleRate, rampDuration, nChannels);

%%%
% The samples can be send to the audio driver at a given time using signals

% At the time of 'newTrial', send samples to audio device
audio.default = events.newTrial.map(samples);

%%%
% The samples can be generated on the fly using |mapn|.  In this example,
% each time the the tone amplitude and frequency parameters update, the
% samples are recalculated
toneSamples = mapn(...
  p.toneFrequency, ... % frequency
  0.1, sampleRate,... % duration and sample rate
  0.02, nChannels, ... % ramp and number of channels
  @aud.pureTone);
audio.default = events.newTrial.then(p.toneAmplitude * samples);

%%%
% The below code will produce a list of available device names that can be
% referenced during the experiment:
rig = hw.devices;
availiable_devs = {rig.audioDevices.DeviceName}' 

%% Summary
% 
% # the time signal, t, always updates before all other signals.
% # events.expStart updates once and only once during an experiment.
% # All parameter signals update simultaneously every trial.  If they are
% global parameters, they update with the same value each time.
% # events.expStop updates once and only once at the end of the experiment.
%  If you define it in your expDef, when it takes a value the experiment
%  will end.
% # All signals assigned to the events subscriptable signal will be logged
% and saved in your block file.  You will not be able to recover the values
% or update times of signals that aren't part of the inputs, parameters or
% events signals.
% # When events.endTrial updates, the trial ends.  If its value is
% non-zero / true, the next trial condition is selected and
% events.repeatNum resets to 1.  If its value is 0 / false, the exact same
% parameters are repeated the following trial, and events.repeatNum will
% increase by 1.
% # The only signal that must be defined in an expDef is the
% events.endTrial signal.
% 

%% Etc.
% Author: Miles Wells
%
% v0.0.2

%%%
% Next section <./visual_stimuli.html Creating stimuli>.
%
% See also <./using_signals.html Using Signals>.

%#ok<*NOPTS>
##### SOURCE END #####
--></body></html>