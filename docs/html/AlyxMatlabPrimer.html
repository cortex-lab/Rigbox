
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Introduction</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-08-21"><meta name="DC.source" content="AlyxMatlabPrimer.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Introduction</h1><!--introduction--><p><a href="https://github.com/cortex-lab/alyx">Alyx</a> is a light-weight meta-database for colony management and experimental logging.  Its purpose is to facilitate the recording and sharing of experimental data within the neuroscience community.  It is currently adopted by the <a href="https://www.internationalbrainlab.com/">International Brain Lab</a> (IBL).</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Example dataset creation &amp; file registration on Alyx</a></li><li><a href="#2">Logging in/out</a></li><li><a href="#3">Using endpoints to GET data</a></li><li><a href="#4">Posting data</a></li><li><a href="#5">Datasets</a></li><li><a href="#6">Advance session search</a></li><li><a href="#7">Getting file paths</a></li><li><a href="#8">Saving files</a></li><li><a href="#9">File registration</a></li><li><a href="#10">Alyx queue</a></li><li><a href="#11">Debugging with http.jsonPost</a></li><li><a href="#12">Using Alyx with Rigbox</a></li><li><a href="#13">Sending Alyx around</a></li><li><a href="#14">Headless Alyx</a></li><li><a href="#15">MySQL queries</a></li><li><a href="#16">Etc.</a></li></ul></div><h2 id="1">Example dataset creation &amp; file registration on Alyx</h2><p>The simplst way to interface with Alyx via MATLAB is through the RESTful interface.  The Alyx class (found in Rigbox/alyx-matlab/@Alyx) creates an instance of an Alyx object that can be passed around rigs and used to get and post data from/to the database.  NB: Alyx is actually a value class, not a handle one.  More on that later.</p><pre class="codeinput">doc <span class="string">Alyx</span>
</pre><h2 id="2">Logging in/out</h2><p>To instantiate an instance of Alyx, call the constructor like so:</p><pre class="codeinput">ai = Alyx;

<span class="comment">% When called with no arguments, a login window is automatically displayed.</span>
<span class="comment">% To instantiate the object without immediately logging in, call it with</span>
<span class="comment">% the first two arguments empty.  This is useful when you want to set a</span>
<span class="comment">% different database URL from the default before logging in.  NB: The</span>
<span class="comment">% inputs are the Username and Token.</span>
ai = Alyx(<span class="string">''</span>,<span class="string">''</span>);

<span class="comment">% The default database url is set in dat.paths, a member of the dependent</span>
<span class="comment">% Rigbox +dat package.</span>
base = getOr(dat.paths, <span class="string">'databaseURL'</span>)

<span class="comment">% For playing around you may use the following credentials:</span>
baseURL = <span class="string">'https://test.alyx.internationalbrainlab.org'</span>;
user = <span class="string">'test_user'</span>;
pwd = <span class="string">'TapetesBloc18'</span>;

<span class="comment">% To log in use the login method.  Upon success, this sets the Token</span>
<span class="comment">% property with a token from Alyx.  To determine whether you're logged in,</span>
<span class="comment">% use the IsLoggedIn property. After logging in the object automatically</span>
<span class="comment">% flushes any posts in the queue (more later). NB: Alyx is not a handle</span>
<span class="comment">% class, so make sure you assign the output to itself.</span>
ai.IsLoggedIn <span class="comment">% false</span>
ai = ai.login;

ai.IsLoggedIn <span class="comment">% true</span>
ai = ai.logout;

ai.IsLoggedIn <span class="comment">% false</span>
</pre><h2 id="3">Using endpoints to GET data</h2><p>A list of availiable endpoints can be found in the database <a href="https://alyx.readthedocs.io/en/latest/api.html">documentation</a>  Most of these endpoints already have methods associated with them.  For instance the listSubjects method returns a list of subjects from the subjects endpoint:</p><pre class="codeinput">ai = ai.login;
subjects = ai.listSubjects();

<span class="comment">% You can use the getData method to retrieve data directly from the</span>
<span class="comment">% specified endpoint.  For instance to retrieve subject data directly:</span>
subjects = ai.getData(<span class="string">'subjects'</span>); <span class="comment">% NB: This is called by listSubjects</span>

<span class="comment">% getData uses the makeEndpoint method to create the full URL using the</span>
<span class="comment">% BaseURL property.  To interact with a different database instead, either</span>
<span class="comment">% provide the full URL or change the BaseURL property accordingly.  NB: You</span>
<span class="comment">% may need to refresh your token by logging out and back in.</span>
ai.BaseURL = <span class="string">'https://test.dev.alyx.internationalbrainlab.org'</span>;
users = ai.getData(<span class="string">'users'</span>);

<span class="comment">% The data are returned as a struct.  The second output argument is the</span>
<span class="comment">% server status code.  For a full list of status codes and their meanings:</span>
doc <span class="string">matlab.net.http.StatusCode</span>
[users, status] = ai.getData(<span class="string">'users'</span>) <span class="comment">% 200 = OK!</span>

<span class="comment">% To use any URL queries, just add them the endpoint string in the standard</span>
<span class="comment">% URL format:</span>
sessions = ai.getData(<span class="string">'sessions?type=Experiment&amp;subject=ZM_335'</span>)

<span class="comment">% For more info:</span>
doc <span class="string">webread</span>

<span class="comment">% The query options are set on the server side.  You can find which options</span>
<span class="comment">% are availible for each endpoint by vising the alyx documentation (see</span>
<span class="comment">% above).  This information is also availiable on the DJANGO API page but</span>
<span class="comment">% be warned it is slow to load as you are running a GET within the browser:</span>

<span class="comment">% Example: https://test.alyx.internationalbrainlab.org/sessions</span>
<span class="comment">% HTTP 200 OK % HTTP version</span>
<span class="comment">% Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS % Methods allowed</span>
<span class="comment">% Content-Type: application/json % Post using Alyx.jsonPost</span>
<span class="comment">% Vary: Accept</span>
</pre><h2 id="4">Posting data</h2><p>POST requests (those that create new records on Alyx) can be made with the postData method.  Upon success postData returns the created record. For creating a new experiment, use the <tt>newExp</tt> method.  This is the same as the <tt>dat.newExp</tt> function, but with the addition of creating session records on Alyx.</p><p><tt>Alyx.newExp</tt> first creates a base session if one doesn't exist.  This is a session corresponding to a particular day (the yyyy-mm-dd part of an experiment reference, see <tt>dat.parseExpRef</tt>).  On Alyx, base sessions have the type 'Base'. It then creates a new subsession.  Subsessions correspond to the experiment sequence number of an expRef.  On the database, these sessions are identified by the type field being 'Experiment'.  For example, you may have three subsessions related to a base session, meaning on that particular day, you ran three expeiments, perhaps training the mouse on a rig, then later doing RF mapping, then doing some imaging with behaviour.  Alyx supports further nesting of sessions, however <tt>Alyx.newExp</tt> currently doesn't support this.</p><p>The <tt>newExp</tt> method returns the new subsession URL which may then be saved in SessionURL property of the object for further posts.  This URL is in itself an endpoint for ameding (with PATCH) session information (or even creating a nested subsession).</p><p>Before you can create a session a few things must be set up: # A subject folder must first be created in your main experiment repository:</p><pre class="codeinput">subject = <span class="string">'ZM_335'</span>; <span class="comment">% Subject for this test</span>
mkdir(fullfile(dat.reposPath(<span class="string">'main'</span>, <span class="string">'master'</span>), subject)); <span class="comment">% Subject folder</span>
<span class="comment">% # The location of your main repository must be added to Alyx through the</span>
<span class="comment">% admin interface.</span>
web([ai.BaseURL <span class="string">'/admin/datarepository/'</span>]) <span class="comment">% Not accessible on test alyx</span>
<span class="comment">% The hostname field must match the root of the file path:</span>
rmEmpty({ai.getData(<span class="string">'data-repository'</span>).hostname}')

<span class="comment">% Let's create a session for our subject:</span>
[expRef, expSeq, url] = ai.newExp(<span class="string">'ZM_335'</span>);
ai.SessionURL = url; <span class="comment">% Now holds the current (most recent) subsession URL.</span>

<span class="comment">% Let's update the session narrative:</span>
comments = <span class="string">'This is a dummy session'</span>;
narrative = ai.updateNarrative(comments, ai.SessionURL);

<span class="comment">% Let's manually create a nested subsession</span>
d = struct;
d.subject = <span class="string">'test'</span>;
d.procedures = {<span class="string">'Behavior training/tasks'</span>};
d.narrative = <span class="string">'sub-sub-session'</span>;
d.start_time = ai.datestr(now); <span class="comment">% date in Alyx format</span>
d.type = <span class="string">'Experiment'</span>; <span class="comment">% Sub-sessions have the type 'Experiment'</span>
d.parent_session = ai.SessionURL;
d.number = 1; <span class="comment">% First session of today</span>

[subsession, statusCode] = ai.postData(<span class="string">'sessions'</span>, d)

<span class="comment">% With this method you can also make PUT and PATCH requests to amending a</span>
<span class="comment">% record.  NB: Only for those endpoints with these options availible.</span>
<span class="comment">% Let's update the session's end time:</span>
d = struct(<span class="string">'end_time'</span>, ai.datestr(now)); <span class="comment">% Subject is a required field for PUT</span>
ai.postData(ai.SessionURL, d, <span class="string">'patch'</span>) <span class="comment">% Update the record with PATCH</span>

<span class="comment">% The postData method uses the jsonPost method, which in turn uses the</span>
<span class="comment">% built in MATLAB function webwrite.  More info:</span>
doc <span class="string">Alyx.jsonPost</span>
doc <span class="string">webwrite</span>

clear <span class="string">d</span> <span class="string">subsession</span> <span class="string">statusCode</span> <span class="string">url</span> <span class="string">comments</span> <span class="string">expSeq</span>
</pre><h2 id="5">Datasets</h2><p>One of the purposes of Alyx is to make sharing data to a wider group simple and accessible.  In order to do this effectively there are a few things imposed on the user in terms of how data and meta-data are stored:</p><pre class="codeinput"><span class="comment">% 1. Files must be stored in a directory by mouse name, then experiment</span>
<span class="comment">% date (corresponding to the base session on Alyx), then</span>
<span class="comment">% experiment/sequence number (corresponding to subsessions on Alyx). Alyx</span>
<span class="comment">% infers information about the files based on this directory structure.</span>

<span class="comment">% 2. Where the files are saved must correspond to a data repository that</span>
<span class="comment">% has been created on Alyx.  One such example is zubjects.  For the IBL</span>
<span class="comment">% collaboration, the data repository records are used by Globus to map the</span>
<span class="comment">% drive in order to copy selected files to The Flatiron Institute</span>
<span class="comment">% (availiable to other labs - only subjects under the project 'IBL' are</span>
<span class="comment">% copied).  More information can be found in the</span>
<span class="comment">% &lt;https://alyx.readthedocs.io/en/latest/models.html#data alyx database</span>
<span class="comment">% documentation&gt;:</span>
web(<span class="string">'https://alyx.readthedocs.io/en/latest/models.html#data'</span>)

<span class="comment">% 3. The files must have a corresponding dataset type.  This is a record on</span>
<span class="comment">% Alyx that includes a human readable description of what the data are and</span>
<span class="comment">% a filename pattern for identifying the file.  It is suggested that the</span>
<span class="comment">% filename pattern correspond either to the ALF standard, or the Rigbox</span>
<span class="comment">% standard of expRef_type (more on this later).  Datasets, like sessions,</span>
<span class="comment">% are hierachical, for instance you could have a parent dataset type (with</span>
<span class="comment">% no corresponding files) that is called 'twoPhoton', with the ALF pattern</span>
<span class="comment">% '*_2P*.*'.  Child dataset types could include ROI files (e.g.</span>
<span class="comment">% '*_2P_ROI.*') and raw frames (e.g. '*_2P_ROI.*'). More info:</span>
<span class="comment">% https://alyx.internationalbrainlab.net/admin/data/datasettype/</span>
web(<span class="string">'https://github.com/cortex-lab/ALF'</span>)
<span class="comment">% The list of current and proposed ALFs may be found</span>
<span class="comment">% &lt;https://docs.google.com/spreadsheets/d/1DqyQ-Ho4eObR0B4nZMQz397TAUReaef-9dRWKwIa3JM/edit#gid=0</span>
<span class="comment">% here&gt;</span>
<span class="comment">%</span>

<span class="comment">% 4. The files must have a valid format, defined on Alyx by the data format</span>
<span class="comment">% records.  These records include a description of the file format, the</span>
<span class="comment">% filename pattern (e.g. '*.mat' or '*.*.npy' for ALF files), and the</span>
<span class="comment">% function name for loading the file in MATLAB and Python.  More info:</span>
<span class="comment">% https://alyx.internationalbrainlab.net/admin/data/dataformat/</span>
</pre><h2 id="6">Advance session search</h2><p>Sessions can be queried in an sophisticated way with the <tt>getSessions</tt> method:</p><pre class="codeinput">help <span class="string">ai.getSessions</span>

<span class="comment">% Session eids can be used as input, as well as experiment reference</span>
<span class="comment">% strings.  A single value can be passed in or a whole list:</span>
sessions = ai.getSessions(<span class="string">'cf264653-2deb-44cb-aa84-89b82507028a'</span>) <span class="comment">% eid</span>
sessions = ai.getSessions(<span class="string">'2018-07-13_1_flowers'</span>) <span class="comment">% expRef</span>

<span class="comment">% It can be used to convert session eids to expRefs:</span>
refs = [<span class="string">"2018-07-13_1_flowers"</span> <span class="string">"2019-08-16_2_ZM_335"</span>];
[~, eids] = ai.getSessions(refs)

<span class="comment">% Sessions can be filtered based on subject, date, or associated dataset</span>
<span class="comment">% types:</span>
sessions = ai.getSessions(<span class="string">'cf264653-2deb-44cb-aa84-89b82507028a'</span>, <span class="keyword">...</span>
  <span class="string">'subject'</span>, {<span class="string">'flowers'</span>, <span class="string">'ZM_307'</span>})
sessions = ai.getSessions(<span class="string">'lab'</span>, <span class="string">'cortexlab'</span>, <span class="keyword">...</span>
  <span class="string">'date_range'</span>, datenum([2018 8 28 ; 2018 8 31]))
sessions = ai.getSessions(<span class="string">'date'</span>, now)
sessions = ai.getSessions(<span class="string">'data'</span>, {<span class="string">'clusters.probes'</span>, <span class="string">'eye.blink'</span>})
</pre><h2 id="7">Getting file paths</h2><p>The <tt>+dat</tt> package is primarily used to retrieve data from a rig's repositories, however this information can also be retrieved from the database, as well as any additional remote locations if Globus is set up:</p><pre class="codeinput">help <span class="string">Alyx.getFile</span>

<span class="comment">% Get paths associated with a particular session's dataset:</span>
eid = <span class="string">'c41dd877-d511-42cb-90a3-01bb19297117'</span>; <span class="comment">% dataset uuid</span>
[fullPath, exists] = ai.getFile(eid)
<span class="comment">% If exist == false it means the file was registered to that location but</span>
<span class="comment">% has not yet been copied there.</span>

<span class="comment">% We can retrieve only 'remote' files, meaning those in repositories with a</span>
<span class="comment">% data_url field:</span>
[fullPath, exists] = ai.getFile(eid, <span class="string">'dataset'</span>, true) <span class="comment">% remoteOnly = true</span>

<span class="comment">% Finally we can also retrieve paths for inividual file records:</span>
eids = [<span class="string">"00c3df4f-99ab-4cc0-b305-b508bcfb07ab"</span>,<span class="keyword">...</span>
      <span class="string">"0b747a70-1309-4f84-98f6-5f3aa9815b4c"</span>] <span class="comment">% File record uuids</span>
fullPath = ai.getFile(eids, <span class="string">'file'</span>, true) <span class="comment">% remoteOnly = true</span>

<span class="comment">% Note: Inputs may be cellstr, char or string.  The first output will be</span>
<span class="comment">% either a char or cellstr.</span>
</pre><h2 id="8">Saving files</h2><p>Saving files in a standard way can be easily achieved by using dat.expFilePath to return the path and file name for your data.  The main data repository is defined in <a href="./using_dat_package.html">dat.paths</a>, the folder tree by dat.canstructExpRef (used by dat.newExp), and the file name is constructed from the expRef + '_filetype'.  The list of file types are found here:</p><pre class="codeinput">opentoline(which(<span class="string">'dat.expFilePath'</span>),45,1)
doc <span class="string">dat</span> <span class="comment">% further info</span>
open(fullfile(getOr(dat.paths, <span class="string">'rigbox'</span>), <span class="string">'docs'</span>, <span class="string">'using_dat_package.m'</span>))

<span class="comment">% For example, let's create a new experiment, then save the associated</span>
<span class="comment">% eye tracking data:</span>
expRef = ai.newExp(subject); <span class="comment">% Create new experiment ref and Alyx (sub)session</span>
fullpath = dat.expFilePath(expRef, <span class="string">'eyetracking'</span>, <span class="string">'master'</span>)
<span class="comment">% Without specifying the which repo location (i.e. 'master' or 'local'),</span>
<span class="comment">% you get both paths returned.</span>
fullpaths = dat.expFilePath(expRef, <span class="string">'eyetracking'</span>)

clear <span class="string">fullpaths</span>
</pre><h2 id="9">File registration</h2><p>In order to successfully register a file to Alyx, you must make sure the dataset type, repository and format records are created on the database first.  To register a file, you can use the registerFile method:</p><pre class="codeinput">[datasets, filerecords] = ai.registerFile(fullpath) <span class="comment">% Register a specific file</span>
<span class="comment">% The returned dataset records should contain the associated session URL</span>
<span class="comment">% and the dataset type, as well as a list of filerecords.  The filerecords</span>
<span class="comment">% contain the path to the files and what repository they're found on.</span>

<span class="comment">% You can also input a cell array of paths, including whole directories:</span>
expPath = dat.expPath(expRef, <span class="string">'main'</span>, <span class="string">'master'</span>) <span class="comment">% Returns the directory</span>
[datasets, filerecords] = ai.registerFile(expPath)
<span class="comment">% Returns the datasets are filerecords of all successfully registered files</span>
<span class="comment">% in the provided directory.  You can register the same file multiple</span>
<span class="comment">% times.  If a filerecord already exists, Alyx simply returns the original.</span>
</pre><h2 id="10">Alyx queue</h2><p>All posts to Alyx are first saved as a JSON file in a location specified by the objects QueueDir property.  This means that when a post fails for reasons other than user error, the posts remain in the queue until further notice.  Each time a user 'logs in', the queue is flushed, meaning that all saved posts are re-submitted to Alyx.  You can manually flush the queue by called in the flushQueue method:</p><pre class="codeinput">ai.flushQueue
</pre><h2 id="11">Debugging with http.jsonPost</h2><p>Unfortunately, the MATLAB built in http interface functions are limited in terms of debugging, as they don't directly return the server's responses upon failure.  Status codes must be extracted from the error message bodies, and the full reponse of the server is usually not returned.  In order to debug your Alyx posts, you can use the missing http package's jsonPost function instead.  See line 47 of <tt>Alyx.flushQueue</tt>:</p><pre class="codeinput">opentoline(which(<span class="string">'flushQueue'</span>),47,1)
web(<span class="string">'https://github.com/psexton/missing-http/releases'</span>) <span class="comment">% To download toolbox</span>
</pre><h2 id="12">Using Alyx with Rigbox</h2><p>Alys can be used with Rigbox.  In this way subject information such as weight can be posted to Alyx through MC or the AlyxPanel GUI, and files and reward volumes can be posted automatically at the end of the session.</p><p>To activate Alyx simply set the databaseURL field in <tt>dat.paths</tt> to a non-empty string (should be a valid database url).</p><pre class="codeinput">getOr(dat.paths, <span class="string">'databaseURL'</span>)

<span class="comment">% Once active you will be able to use the standalone AlyxPanel and the one</span>
<span class="comment">% in MC:</span>
doc <span class="string">eui.AlyxPanel</span>

<span class="comment">% Let's create a new panel:</span>
eui.AlyxPanel;

<span class="comment">% You can log in through this panel, select subjects and view session</span>
<span class="comment">% histories.  You can also post weight and water information to alyx here.</span>
<span class="comment">% If you have a digital weigh scale installed, you can directly record the</span>
<span class="comment">% weights by clicking the 'record' button (otherwise appears as 'manual</span>
<span class="comment">% weight').  More info on setting this up can be found here:</span>
hw_setup = fullfile(getOr(dat.paths, <span class="string">'rigbox'</span>), <span class="string">'docs'</span>, <span class="string">'setup'</span>, <span class="string">'hardware_config.m'</span>);
opentoline(hw_setup, 497, 1)
</pre><h2 id="13">Sending Alyx around</h2><p>An Alyx instance can be sent between rigs in one of two ways: 1. Via Java Websockets using the io.WSJCommunicator.server/client object.   This object uses the hlp_serialize/deserialize functions to send the   object. 2. Via UDP using Rigbox services objects (using udp and pnet functions).   The Alyx.parseAlyxInstance method can be used to convert the object   into a JSON string and back again. Both methods ultimately use saveobj and loadobj methods to convert the Alyx object.  This isn't really important to know. More info on <a href="./using_services.html">services</a>:</p><pre class="codeinput">doc <span class="string">Alyx.parseAlyxInstance</span> <span class="comment">% Used by srv.BasicUDPService and tl.mpepListener</span>
doc <span class="string">io.WSJCommunicator.server</span> <span class="comment">% Used by expServer to communicate with mc</span>
doc <span class="string">srv.StimulusControl</span> <span class="comment">% Used by mc to communicate with expServer</span>
open(fullfile(getOr(dat.paths, <span class="string">'rigbox'</span>), <span class="string">'docs'</span>, <span class="string">'setup'</span>, <span class="string">'using_services.m'</span>))
</pre><h2 id="14">Headless Alyx</h2><p>Before sending an instance of Alyx to a stimulus computer, consider setting the Headless property to 'true'.  This means that the object will not spawn any user prompts, and will supress some errors.  This can also be set when the database become unreachable.  All posts are still saved in the queue for when a user logs in on that computer.  NB: Even when headless the Alyx object may throw errors.  On recording computers, always put GET/POST related methods in a try-catch, or only attempt such things at the end of the experiment</p><pre class="codeinput">ai.Headless = true;
ai = ai.logout;
ai = ai.login; <span class="comment">% Dialog surpressed</span>
ai.registerFile(expPath); <span class="comment">% Dialog surpressed</span>
</pre><h2 id="15">MySQL queries</h2><p>One can also interact with Alyx through connection to the underlying MySQL database.  This currently isn't really supported by the alyx-matlab package and isn't encouraged.  More information:</p><pre class="codeinput">alyxPath = fileparts(which(<span class="string">'Alyx'</span>));
open(fullfile(alyxPath, <span class="string">'..'</span>, <span class="string">'docs'</span>, <span class="string">'sql'</span>, <span class="string">'openAlyxSQL.m'</span>))
open(fullfile(alyxPath, <span class="string">'..'</span>, <span class="string">'docs'</span>, <span class="string">'sql'</span>, <span class="string">'expFilePath.m'</span>))
</pre><h2 id="16">Etc.</h2><p>Author: Miles Wells</p><p>v1.1.0</p><pre class="codeinput"><span class="comment">%#ok&lt;*NASGU,*ASGLU,*NOPTS&gt;</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Introduction 
% <https://github.com/cortex-lab/alyx Alyx> is a light-weight meta-database
% for colony management and experimental logging.  Its purpose is to
% facilitate the recording and sharing of experimental data within the
% neuroscience community.  It is currently adopted by the
% <https://www.internationalbrainlab.com/ International Brain Lab> (IBL).

%% Example dataset creation & file registration on Alyx
% The simplst way to interface with Alyx via MATLAB is through the RESTful
% interface.  The Alyx class (found in Rigbox/alyx-matlab/@Alyx) creates an
% instance of an Alyx object that can be passed around rigs and used to get
% and post data from/to the database.  NB: Alyx is actually a value class,
% not a handle one.  More on that later.
doc Alyx

%% Logging in/out
% To instantiate an instance of Alyx, call the constructor like so:
ai = Alyx;

% When called with no arguments, a login window is automatically displayed.
% To instantiate the object without immediately logging in, call it with
% the first two arguments empty.  This is useful when you want to set a
% different database URL from the default before logging in.  NB: The
% inputs are the Username and Token.
ai = Alyx('','');

% The default database url is set in dat.paths, a member of the dependent
% Rigbox +dat package.  
base = getOr(dat.paths, 'databaseURL')

% For playing around you may use the following credentials:
baseURL = 'https://test.alyx.internationalbrainlab.org';
user = 'test_user';
pwd = 'TapetesBloc18';

% To log in use the login method.  Upon success, this sets the Token
% property with a token from Alyx.  To determine whether you're logged in,
% use the IsLoggedIn property. After logging in the object automatically
% flushes any posts in the queue (more later). NB: Alyx is not a handle
% class, so make sure you assign the output to itself.
ai.IsLoggedIn % false
ai = ai.login;

ai.IsLoggedIn % true
ai = ai.logout;

ai.IsLoggedIn % false

%% Using endpoints to GET data
% A list of availiable endpoints can be found in the database
% <https://alyx.readthedocs.io/en/latest/api.html documentation>  Most of
% these endpoints already have methods associated with them.  For instance
% the listSubjects method returns a list of subjects from the subjects
% endpoint:
ai = ai.login;
subjects = ai.listSubjects();

% You can use the getData method to retrieve data directly from the
% specified endpoint.  For instance to retrieve subject data directly:
subjects = ai.getData('subjects'); % NB: This is called by listSubjects

% getData uses the makeEndpoint method to create the full URL using the
% BaseURL property.  To interact with a different database instead, either
% provide the full URL or change the BaseURL property accordingly.  NB: You
% may need to refresh your token by logging out and back in.
ai.BaseURL = 'https://test.dev.alyx.internationalbrainlab.org';
users = ai.getData('users');

% The data are returned as a struct.  The second output argument is the
% server status code.  For a full list of status codes and their meanings:
doc matlab.net.http.StatusCode
[users, status] = ai.getData('users') % 200 = OK!

% To use any URL queries, just add them the endpoint string in the standard
% URL format:
sessions = ai.getData('sessions?type=Experiment&subject=ZM_335')

% For more info:
doc webread

% The query options are set on the server side.  You can find which options
% are availible for each endpoint by vising the alyx documentation (see
% above).  This information is also availiable on the DJANGO API page but
% be warned it is slow to load as you are running a GET within the browser:

% Example: https://test.alyx.internationalbrainlab.org/sessions
% HTTP 200 OK % HTTP version
% Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS % Methods allowed
% Content-Type: application/json % Post using Alyx.jsonPost
% Vary: Accept

%% Posting data
% POST requests (those that create new records on Alyx) can be made with
% the postData method.  Upon success postData returns the created record.
% For creating a new experiment, use the |newExp| method.  This is the same
% as the |dat.newExp| function, but with the addition of creating session
% records on Alyx.  
%
% |Alyx.newExp| first creates a base session if one doesn't exist.  This is
% a session corresponding to a particular day (the yyyy-mm-dd part of an
% experiment reference, see |dat.parseExpRef|).  On Alyx, base sessions
% have the type 'Base'. It then creates a new subsession.  Subsessions
% correspond to the experiment sequence number of an expRef.  On the
% database, these sessions are identified by the type field being
% 'Experiment'.  For example, you may have three subsessions related to a
% base session, meaning on that particular day, you ran three expeiments,
% perhaps training the mouse on a rig, then later doing RF mapping, then
% doing some imaging with behaviour.  Alyx supports further nesting of
% sessions, however |Alyx.newExp| currently doesn't support this.
%
% The |newExp| method returns the new subsession URL which may then be
% saved in SessionURL property of the object for further posts.  This URL
% is in itself an endpoint for ameding (with PATCH) session information (or
% even creating a nested subsession). 
%
% Before you can create a session a few things must be set up:
% # A subject folder must first be created in your main experiment
% repository:
subject = 'ZM_335'; % Subject for this test
mkdir(fullfile(dat.reposPath('main', 'master'), subject)); % Subject folder
% # The location of your main repository must be added to Alyx through the
% admin interface.
web([ai.BaseURL '/admin/datarepository/']) % Not accessible on test alyx
% The hostname field must match the root of the file path:
rmEmpty({ai.getData('data-repository').hostname}')

% Let's create a session for our subject:
[expRef, expSeq, url] = ai.newExp('ZM_335');
ai.SessionURL = url; % Now holds the current (most recent) subsession URL.

% Let's update the session narrative:
comments = 'This is a dummy session';
narrative = ai.updateNarrative(comments, ai.SessionURL);

% Let's manually create a nested subsession
d = struct;
d.subject = 'test';
d.procedures = {'Behavior training/tasks'};
d.narrative = 'sub-sub-session';
d.start_time = ai.datestr(now); % date in Alyx format
d.type = 'Experiment'; % Sub-sessions have the type 'Experiment'
d.parent_session = ai.SessionURL;
d.number = 1; % First session of today

[subsession, statusCode] = ai.postData('sessions', d) 

% With this method you can also make PUT and PATCH requests to amending a
% record.  NB: Only for those endpoints with these options availible.
% Let's update the session's end time:
d = struct('end_time', ai.datestr(now)); % Subject is a required field for PUT
ai.postData(ai.SessionURL, d, 'patch') % Update the record with PATCH

% The postData method uses the jsonPost method, which in turn uses the
% built in MATLAB function webwrite.  More info:
doc Alyx.jsonPost
doc webwrite

clear d subsession statusCode url comments expSeq
%% Datasets
% One of the purposes of Alyx is to make sharing data to a wider group
% simple and accessible.  In order to do this effectively there are a few
% things imposed on the user in terms of how data and meta-data are stored:

% 1. Files must be stored in a directory by mouse name, then experiment
% date (corresponding to the base session on Alyx), then
% experiment/sequence number (corresponding to subsessions on Alyx). Alyx
% infers information about the files based on this directory structure.

% 2. Where the files are saved must correspond to a data repository that
% has been created on Alyx.  One such example is zubjects.  For the IBL
% collaboration, the data repository records are used by Globus to map the
% drive in order to copy selected files to The Flatiron Institute
% (availiable to other labs - only subjects under the project 'IBL' are
% copied).  More information can be found in the
% <https://alyx.readthedocs.io/en/latest/models.html#data alyx database
% documentation>: 
web('https://alyx.readthedocs.io/en/latest/models.html#data')

% 3. The files must have a corresponding dataset type.  This is a record on
% Alyx that includes a human readable description of what the data are and
% a filename pattern for identifying the file.  It is suggested that the
% filename pattern correspond either to the ALF standard, or the Rigbox
% standard of expRef_type (more on this later).  Datasets, like sessions,
% are hierachical, for instance you could have a parent dataset type (with
% no corresponding files) that is called 'twoPhoton', with the ALF pattern
% '*_2P*.*'.  Child dataset types could include ROI files (e.g.
% '*_2P_ROI.*') and raw frames (e.g. '*_2P_ROI.*'). More info:
% https://alyx.internationalbrainlab.net/admin/data/datasettype/
web('https://github.com/cortex-lab/ALF')
% The list of current and proposed ALFs may be found
% <https://docs.google.com/spreadsheets/d/1DqyQ-Ho4eObR0B4nZMQz397TAUReaef-9dRWKwIa3JM/edit#gid=0
% here>
% 

% 4. The files must have a valid format, defined on Alyx by the data format
% records.  These records include a description of the file format, the
% filename pattern (e.g. '*.mat' or '*.*.npy' for ALF files), and the
% function name for loading the file in MATLAB and Python.  More info:
% https://alyx.internationalbrainlab.net/admin/data/dataformat/

%% Advance session search
% Sessions can be queried in an sophisticated way with the |getSessions|
% method:
help ai.getSessions

% Session eids can be used as input, as well as experiment reference
% strings.  A single value can be passed in or a whole list:
sessions = ai.getSessions('cf264653-2deb-44cb-aa84-89b82507028a') % eid
sessions = ai.getSessions('2018-07-13_1_flowers') % expRef

% It can be used to convert session eids to expRefs:
refs = ["2018-07-13_1_flowers" "2019-08-16_2_ZM_335"];
[~, eids] = ai.getSessions(refs)

% Sessions can be filtered based on subject, date, or associated dataset
% types:
sessions = ai.getSessions('cf264653-2deb-44cb-aa84-89b82507028a', ...
  'subject', {'flowers', 'ZM_307'})
sessions = ai.getSessions('lab', 'cortexlab', ...
  'date_range', datenum([2018 8 28 ; 2018 8 31]))
sessions = ai.getSessions('date', now)
sessions = ai.getSessions('data', {'clusters.probes', 'eye.blink'})

%% Getting file paths
% The |+dat| package is primarily used to retrieve data from a rig's
% repositories, however this information can also be retrieved from the
% database, as well as any additional remote locations if Globus is set up:
help Alyx.getFile

% Get paths associated with a particular session's dataset:
eid = 'c41dd877-d511-42cb-90a3-01bb19297117'; % dataset uuid
[fullPath, exists] = ai.getFile(eid)
% If exist == false it means the file was registered to that location but
% has not yet been copied there.

% We can retrieve only 'remote' files, meaning those in repositories with a
% data_url field:
[fullPath, exists] = ai.getFile(eid, 'dataset', true) % remoteOnly = true

% Finally we can also retrieve paths for inividual file records:
eids = ["00c3df4f-99ab-4cc0-b305-b508bcfb07ab",...
      "0b747a70-1309-4f84-98f6-5f3aa9815b4c"] % File record uuids
fullPath = ai.getFile(eids, 'file', true) % remoteOnly = true

% Note: Inputs may be cellstr, char or string.  The first output will be
% either a char or cellstr.

%% Saving files
% Saving files in a standard way can be easily achieved by using
% dat.expFilePath to return the path and file name for your data.  The main
% data repository is defined in <./using_dat_package.html dat.paths>, the
% folder tree by dat.canstructExpRef (used by dat.newExp), and the file
% name is constructed from the expRef + '_filetype'.  The list of file
% types are found here:
opentoline(which('dat.expFilePath'),45,1)
doc dat % further info
open(fullfile(getOr(dat.paths, 'rigbox'), 'docs', 'using_dat_package.m'))

% For example, let's create a new experiment, then save the associated
% eye tracking data:
expRef = ai.newExp(subject); % Create new experiment ref and Alyx (sub)session
fullpath = dat.expFilePath(expRef, 'eyetracking', 'master')
% Without specifying the which repo location (i.e. 'master' or 'local'),
% you get both paths returned.
fullpaths = dat.expFilePath(expRef, 'eyetracking')

clear fullpaths
%% File registration
% In order to successfully register a file to Alyx, you must make sure the
% dataset type, repository and format records are created on the database
% first.  To register a file, you can use the registerFile method:
[datasets, filerecords] = ai.registerFile(fullpath) % Register a specific file
% The returned dataset records should contain the associated session URL
% and the dataset type, as well as a list of filerecords.  The filerecords
% contain the path to the files and what repository they're found on.

% You can also input a cell array of paths, including whole directories:
expPath = dat.expPath(expRef, 'main', 'master') % Returns the directory
[datasets, filerecords] = ai.registerFile(expPath)
% Returns the datasets are filerecords of all successfully registered files
% in the provided directory.  You can register the same file multiple
% times.  If a filerecord already exists, Alyx simply returns the original.

%% Alyx queue
% All posts to Alyx are first saved as a JSON file in a location specified
% by the objects QueueDir property.  This means that when a post fails for
% reasons other than user error, the posts remain in the queue until
% further notice.  Each time a user 'logs in', the queue is flushed,
% meaning that all saved posts are re-submitted to Alyx.  You can manually
% flush the queue by called in the flushQueue method:
ai.flushQueue

%% Debugging with http.jsonPost
% Unfortunately, the MATLAB built in http interface functions are limited
% in terms of debugging, as they don't directly return the server's
% responses upon failure.  Status codes must be extracted from the error
% message bodies, and the full reponse of the server is usually not
% returned.  In order to debug your Alyx posts, you can use the missing
% http package's jsonPost function instead.  See line 47 of
% |Alyx.flushQueue|:
opentoline(which('flushQueue'),47,1)
web('https://github.com/psexton/missing-http/releases') % To download toolbox

%% Using Alyx with Rigbox
% Alys can be used with Rigbox.  In this way subject information such as
% weight can be posted to Alyx through MC or the AlyxPanel GUI, and files
% and reward volumes can be posted automatically at the end of the session.
%
% To activate Alyx simply set the databaseURL field in |dat.paths| to a
% non-empty string (should be a valid database url).
getOr(dat.paths, 'databaseURL')

% Once active you will be able to use the standalone AlyxPanel and the one
% in MC:
doc eui.AlyxPanel

% Let's create a new panel:
eui.AlyxPanel;

% You can log in through this panel, select subjects and view session
% histories.  You can also post weight and water information to alyx here.
% If you have a digital weigh scale installed, you can directly record the
% weights by clicking the 'record' button (otherwise appears as 'manual
% weight').  More info on setting this up can be found here:
hw_setup = fullfile(getOr(dat.paths, 'rigbox'), 'docs', 'setup', 'hardware_config.m');
opentoline(hw_setup, 497, 1)

%% Sending Alyx around
% An Alyx instance can be sent between rigs in one of two ways:
% 1. Via Java Websockets using the io.WSJCommunicator.server/client object.
%   This object uses the hlp_serialize/deserialize functions to send the
%   object.
% 2. Via UDP using Rigbox services objects (using udp and pnet functions).
%   The Alyx.parseAlyxInstance method can be used to convert the object
%   into a JSON string and back again.
% Both methods ultimately use saveobj and loadobj methods to convert the
% Alyx object.  This isn't really important to know.
% More info on <./using_services.html services>: 
doc Alyx.parseAlyxInstance % Used by srv.BasicUDPService and tl.mpepListener
doc io.WSJCommunicator.server % Used by expServer to communicate with mc
doc srv.StimulusControl % Used by mc to communicate with expServer
open(fullfile(getOr(dat.paths, 'rigbox'), 'docs', 'setup', 'using_services.m'))

%% Headless Alyx
% Before sending an instance of Alyx to a stimulus computer, consider
% setting the Headless property to 'true'.  This means that the object will
% not spawn any user prompts, and will supress some errors.  This can also
% be set when the database become unreachable.  All posts are still saved
% in the queue for when a user logs in on that computer.  NB: Even when
% headless the Alyx object may throw errors.  On recording computers,
% always put GET/POST related methods in a try-catch, or only attempt such
% things at the end of the experiment
ai.Headless = true;
ai = ai.logout;
ai = ai.login; % Dialog surpressed
ai.registerFile(expPath); % Dialog surpressed

%% MySQL queries
% One can also interact with Alyx through connection to the underlying
% MySQL database.  This currently isn't really supported by the alyx-matlab
% package and isn't encouraged.  More information:
alyxPath = fileparts(which('Alyx'));
open(fullfile(alyxPath, '..', 'docs', 'sql', 'openAlyxSQL.m'))
open(fullfile(alyxPath, '..', 'docs', 'sql', 'expFilePath.m'))

%% Etc.
% Author: Miles Wells
%
% v1.1.0

%#ok<*NASGU,*ASGLU,*NOPTS>
##### SOURCE END #####
--></body></html>