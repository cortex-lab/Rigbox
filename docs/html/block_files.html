
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Working with block files</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-03-09"><meta name="DC.source" content="block_files.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Working with block files</h1><!--introduction--><p>Block files are the 'raw' data files produced by Experiments.  They end in '_block.mat'.  They are structs</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Loading a block file</a></li><li><a href="#3">Basic block structure</a></li><li><a href="#5">SignalsExp block structure</a></li><li><a href="#7">ChoiceWorld block structure</a></li><li><a href="#8">Processing multiple blocks</a></li><li><a href="#18">Notes</a></li><li><a href="#19">Etc.</a></li></ul></div><h2 id="1">Loading a block file</h2><p>Block files are MAT files and can thefore be loaded from their location using the MATLAB <tt>load</tt> function, however the Data package contains a number of functions for making loading more convenient.  The main function is <tt>dat.loadBlock</tt>, which loads and caches a block for a given expRef.  For example here is how you can load the most recent experiment for the subject 'ALK051':</p><pre class="codeinput">expRefs = dat.listExps(<span class="string">'ALK051'</span>);
block = dat.loadBlock(expRefs{end});
</pre><p>If there is no block file found for that experiment, an empty array is returned.  You can check in advance using the <tt>dat.expExists</tt> function. For more information on laoding experiments using the dat package, see the 'Loading experiments' section of the <a href="./using_dat_package.html#5">Data Package user guide</a>.  This guide also has information on loading parameter and rig information.</p><h2 id="3">Basic block structure</h2><p>Block files of all major Experiment types have the following fields:</p><p><b>expRef</b> - The expRef for that experiment (char).</p><p><b>rigName</b> - The name of the stimulus computer which the experiment ran on (char). The rig name itself is set in <tt>hw.devices</tt>, and is by default the computer's hostname.</p><p><b>startDateTime</b> - The start datetime of the experiment as a serial date number (see <a href="https://uk.mathworks.com/help/matlab/ref/datenum.html">datenum</a>).  This is usually set during experiment initialization, in the Experiment's <tt>init</tt> method.</p><p><b>startDateTimeStr</b> - The start datetime of the experiment as a date string in the following format 'dd-mmm-yyyy HH:MM:SS' (day-month-year hour:minute:second, see <a href="https://uk.mathworks.com/help/matlab/ref/datestr.html">datestr</a>).  This is usually set during experiment initialization, in the Experiment's <tt>init</tt> method.</p><p><b>endDateTime</b> - The end datetime of the experiment as a serial date number (see <a href="https://uk.mathworks.com/help/matlab/ref/datenum.html">datenum</a>).  This is usually set during experiment cleanup, in the Experiment's <tt>cleanup</tt> method.</p><p><b>endDateTimeStr</b> - The end datetime of the experiment as a date string in the following format 'dd-mmm-yyyy HH:MM:SS' (day-month-year hour:minute:second, see <a href="https://uk.mathworks.com/help/matlab/ref/datestr.html">datestr</a>).  This is usually set during experiment cleanuo, in the Experiments <tt>cleanup</tt> method.</p><p><b>duration</b> - The duration of the experiment in seconds calculated as the difference between startDateTime and endDateTime, i.e. the length of time between initialization and cleanup.</p><p><b>endStatus</b> - The status of the experiment when ended (char).  There are three options:</p><div><ol><li>quit - the experiment was ended normally (i.e. the 'End' button was pressed in mc, or the quit key was pressed once).  In this situation the experiment post-delay was allowed to elapse before cleanup.</li><li>abort - the experiment was ended with urgency (i.e. the 'Abort' button was pressed in mc, or the quit key was repeatedly pressed).  In this situation the post-delay is aborted and the experiment cleanup routine happens immediately.</li><li>exception - an exception was caught during the experiement and the thus was ended early.</li></ol></div><p><b>exceptionMessage</b> - The error message of the exception thrown during the experiment (char). If no exception occured this field is absent.</p><p>The main experiment phases are also recorded.  These are in absolute seconds according to the <a href="./clocks.html">rig Clock</a>.  These are usually relative to when the runExp command was recieved by expSever.  Below is brief description of these fields.</p><p><b>experimentInitTime</b> - The time in absolute seconds that experiment initialization occured (see <tt>exp.Experiment/init</tt>).  We enter the main experiment loop immediately after this.</p><p><b>experimentStartedTime</b> - The time in absolute seconds that the experiment officially started.  When the pre-delay is set to 0 this happens immedietly after initialization.  In the Signals Experiment Framework this event triggers the expRef to be posted to the expStart event signal.</p><p><b>experimentEndedTime</b> - The time in absolute seconds that the experiment officially ended, that is, when the quit command was received.  In the Signals Experiment Framework this event occurs just after the expEnd event signal updates.</p><p><b>experimentCleanupTime</b> - The time in absolute seconds that we exited the main loop and began the cleanup routine (see <tt>exp.Experiment/cleanup</tt>).</p><p><b>stimWindowUpdateTimes</b> - An array of times in absolute seconds when each Screen flip occured.  See Screen Flip? for more details.</p><h2 id="5">SignalsExp block structure</h2><p>Signals block files can be identified by the presence of an 'expDef' field.  Below is an example of a typical Signals block file.</p><pre>   block =</pre><pre>     struct with fields:</pre><pre>                      expDef: 'C:\Users\User\Documents\Github\rigbox\signals\docs\examples\advancedChoiceWorld.m'
       stimWindowUpdateTimes: [65&times;1 double]
       stimWindowRenderTimes: [65&times;1 double]
                     rigName: 'desktop-c6p85d3'
               startDateTime: 7.3786e+05
            startDateTimeStr: '06-Mar-2020 13:37:46'
                   endStatus: 'quit'
                      expRef: '2020-03-06_1_test'
          experimentInitTime: 1.3031e+06
       experimentStartedTime: 1.3031e+06
         experimentEndedTime: 1.3031e+06
       experimentCleanupTime: 1.3031e+06
                      events: [1&times;1 struct]
                paramsValues: [1&times;6 struct]
                 paramsTimes: [1.3031e+06 1.3031e+06 1.3031e+06 1.3031e+06 1.3031e+06 1.3031e+06]
                      inputs: [1&times;1 struct]
                     outputs: [1&times;1 struct]
                 endDateTime: 7.3786e+05
              endDateTimeStr: '06-Mar-2020 13:38:03'
                    duration: 16.3700</pre><p>Below are descriptions of all fields unique to Signals block files.  All fields ending in 'Times' (not 'DateTimes') are in absolute seconds.</p><p><b>expDef</b> - The full path of the experiment definition function (char).</p><p><b>stimWindowRenderTimes</b> - The times at which the textures finished rendering.  Subtracting these from the update times will give you the software window update lags.</p><p>The other fields unique to the Signals block file contain the values and timestamps of various signals updates throughout the session.  Generally, recorded signals (a.k.a. registries) have two fields associated with them: one ending in 'Values' which contains an array of the values that signal took, and 'Times' which contains an array of equal length of the times in absolute seconds that the signal updated.</p><p><b>events</b> - A scalar struct of values and times of the signals subassigned to the subscriptable events signal.  The essential events are 'expStart', 'expStop', 'newTrial', 'endTrial', 'repeatNum' and 'trialNum'.  Other fields may be present depending on the expDef.  To make future analysis simpler it is worth keeping the names of your event signals consistent.</p><p><b>inputs</b> - A scalar struct of values and times of the input signals.  The essential inputs are 'wheel', 'wheelDeg' and 'wheelRad'.  If configured, there may also be 'lickDetector' fields (see the <a href="./hardware_config.html#29">hardware config guide</a>).  The input signals are the only recorded signals to update exactly once per iteration of the main experiment loop and therefore looking at the update times of these signals can be informative.</p><p><b>outputs</b> - A scalar struct of values and times of the signals subassigned to the subscriptable outputs signal.  The fieldnames of the outputs typically match the ChannelNames property of the daqController object used for that experiment. If no outputs were triggered during the experiment this will be a struct with no fields.</p><p><b>paramsValues</b> - A non-scalar struct of all parameter values for each trial.  The length of this struct matches the length of block.events.newTrialTimes.  Each field is the name of each parameter.  Global parameters are those parameters for which all values are equal (e.g. <tt>numel(unique([block.paramsValues.rewardKey])) == 1</tt>).</p><p><b>paramsTimes</b> - An array of all parameter update times.  Each trial all parameters update simultaneously.</p><h2 id="7">ChoiceWorld block structure</h2><p>ChoiceWorld block files can be identified by the expType field.  Below is an example of a typical ChoiceWorld block file.</p><pre>   block =</pre><pre>     struct with fields:</pre><pre>                        expType: 'ChoiceWorld'
                          trial: [1&times;202 struct]
          stimWindowUpdateTimes: [8885&times;1 double]
           stimWindowUpdateLags: [8885&times;1 double]
                  startDateTime: 7.3686e+05
               startDateTimeStr: '14-Jun-2017 14:39:04'
                     parameters: [1&times;1 struct]
                      endStatus: 'quit'
           rewardDeliveredSizes: [162&times;2 double]
            rewardDeliveryTimes: [1&times;162 double]
                        rigName: 'zredone'
                         expRef: '2017-06-14_2_ALK051'
             experimentInitTime: 0.2818
          experimentStartedTime: 0.3033
            experimentEndedTime: 1.6009e+03
          experimentCleanupTime: 1.6009e+03
                    endDateTime: 7.3686e+05
                 endDateTimeStr: '14-Jun-2017 15:05:45'
             numCompletedTrials: 201
                       duration: 1.6007e+03
           inputSensorPositions: [476057&times;1 double]
       inputSensorPositionTimes: [476057&times;1 double]
                inputSensorGain: 2.0309
                     lickCounts: []
                 lickCountTimes: []</pre><p>Below are descriptions of all fields unique to ChoiceWorld block files. The blocks of other experiment types follow a broadly similar structure. All fields ending in 'Times' (not 'DateTimes') are in absolute seconds.</p><p><b>expType</b> - The experiment type (char), i.e. the name of the experiment chosen from the 'type' dropdown in mc.  Strictly speaking this is the value of the 'type' parameter.  For ChoiceWorld experiments this is obviously 'ChoiceWorld'.</p><p><b>inputSensorGain</b> - The gain of the input with respect to the stimulus (double).  This is a multiplier with the units of visual pixles per rotary encoder 'tick'.  In ChoiceWorld this is set by the <tt>calibrateInputGain</tt> method of <tt>exp.ChoiceWorld</tt>.  It is calculated using the input sensor's 'MillimetersFactor' property, the 'visWheelGain' parameter and the visual pixel density determined by by the stimViewingModel.</p><p><b>inputSensorPositions</b> - An array of absolute values of the input sensor (i.e. '&lt;./hardware_config.html#27 mouseInput&gt;' field of the rig object).</p><p><b>inputSensorPositionTimes</b> - The update times in absolute seconds of the input sensor.  The input sensor is the only recorded event to update exactly once per iteration of the main experiment loop and can therefore be used to determine the performance of the experiment.</p><p><b>lickCounts</b> - The values recorded from the 'lickDetector' field of the rig object (see the <a href="./hardware_config.html#29">hardware config guide</a>).  If no lickDetector is present this is just an empty double.</p><p><b>lickCountTimes</b> - The update times in absolute seconds of the lickDetector sensor.  If no lickDetector is present this is just an empty double.</p><p><b>numCompletedTrials</b> - The total number of completed trials.  The last trial is often incomplete if the experiment is ended by the experimenter.  Therefore this value can be used to trim the 'trials' struct array.</p><p><b>parameters</b> - A copy of the <a href="./glossary.html">global parameters</a> used for this experiment.  See the <a href="./Parameters.html">Parameters guide</a> for more info.</p><p><b>rewardDeliveredSizes</b> - An array of reward delivery sizes in microlitres.  Related to the 'rewardVolume' parameter.</p><p><b>rewardDeliveryTimes</b> - An array of reward delivery times in absolute seconds.  That is, the times at which the command was sent to the hw.DaqController object.</p><p><b>stimWindowUpdateLags</b> - An array of times in seconds between the stimulus window being invalidated and the buffer getting flipped to the screen.</p><p><b>trial</b> - A nonscalar struct of times and outcomes for each trial.  Its length is equal to or one greater than the value of block.numCompleteTrials.  All trial phases and events have fields containing the times in absolute seconds that they occured.  For example 'feebackNegativeStartedTime' and 'inputThresholdCrossedTime'.  The IDs of some of these events are also included (e.g. 'responseMadeID' and 'inputThresholdCrossedID').  The ID value maps for these two fields are defined by the 'responseForThreshold' and 'responseForNoGo' parameter fields.  The 'feedbackType' is -1 for negative and 1 for positive.  Some fields have empty values for some trials indicating that this event didn't occur during that trial (e.g. 'positiveFeedbackStartedTime' is empty for incorrect trials).</p><p>There is also a 'condition' field whose value is a struct of all <a href="./glossary.html">conditional parameter</a> values for that trial:</p><pre>   block.trial(1).condition</pre><pre>   ans =</pre><pre>     struct with fields:</pre><pre>               rewardVolume: [2&times;1 double]
             visCueContrast: [2&times;1 double]
        feedbackForResponse: [3&times;1 double]
       repeatIncorrectTrial: 0
                  repeatNum: 1</pre><h2 id="8">Processing multiple blocks</h2><p>Precessing multiple block can be tricky as some experiments may not have a block file associated with them, may be of a different type and may have very different parameters(1).  There are a few functions availiable in Rigbox for filtering block files, which can make the pre-processing stage simpler.  Below are some ways to filter and load blocks using functional programming tools(2).</p><p>List the expRefs for 'subject'.  NB: dat.listExps can also deal is cell arrays of subjects. Filter out all experiments that don't have a block file.</p><pre class="codeinput">blockExists = @(r) file.exists(dat.expFilePath(r, <span class="string">'block'</span>, <span class="string">'master'</span>));
refs = fun.filter(blockExists, dat.listExps(subject));
</pre><p>Create a sequence from this list and specify a loader function.  The loader function is only called when required, avoiding premature and unnecessary loading.  This is also useful when searching for just one specific block.  For ChoiceWorld we can filter blocks using <tt>dat.loadBlock(ref, 'ChoiceWorld')</tt>.  Below we show how to filter by expDef name.</p><pre class="codeinput">seq = sequence(refs, @dat.loadBlock);
</pre><p>Reverse the sequence so that we search most recent experiments first, and filter using a function that checks the expDef field.  Note that the filter function must return true or false, and gets the output of the loader function (in this case the block file, not the ref) as its input.</p><pre class="codeinput">expDefType = @(b) endsWith(b.expDef, <span class="string">'advancedChoiceWorld.m'</span>);
seq = seq.reverse.filter(expDefType);
b = seq.first; <span class="comment">% Return the most recent advancedChoiceWorld block file</span>
</pre><p>We can return all blocks as a cell array with the following command:</p><pre class="codeinput">blocks = toCell(seq);
</pre><p>If we want only the events structures, we can take them using <tt>map</tt>.</p><pre class="codeinput">events = catStructs(seq.map(@(b) b.events).toCell); <span class="comment">% Return as array of structs</span>
</pre><p>Sometimes those last incomplete trials can be a pain.  Let's trim them before returning using structfun, which applies a function to every field of a struct, and iff, which is like an if-else statement as a one-liner.</p><pre class="codeinput"><span class="comment">% If event one greater than endTrialTimes, trim to the length of</span>
<span class="comment">% endTrialTimes, otherwise return the array as normal.</span>
trimTrials = @(evts) structfun(@(e) <span class="keyword">...</span>
  iff(length(e) == length(evts.endTrialTimes) + 1, <span class="keyword">...</span>
  @() e(1:numel(evts.endTrialTimes)), e), evts, <span class="string">'uni'</span>, 0);
events = seq.map(@(b) b.events).map(trimTrials).toCell; <span class="comment">% Return as cell array</span>
</pre><p>Say we only want blocks where a certain event was recorded, simply filter by that fieldname.  Below is a sophisticated example where we define an anonymous function that searches for a given event.  That way we can apply this filter for multiple events:</p><pre class="codeinput">present = @(e) @(b) isfield(b.events.(e));
seq = seq.filter(present(<span class="string">'prefDecrease'</span>));
</pre><p>Say we want to return the events struct for the first block where the parameter 'rewardSize' was less than 3.  We use the function <tt>getOr</tt> to ensure that we don't get an error for blocks that don't have this parameter.</p><pre class="codeinput">lowRwd = @(b) getOr(b.paramsValues, <span class="string">'rewardSize'</span>, 4) &lt; 3;
events = seq.filter(lowRwd).map(@(b) b.events).first;
</pre><p><tt>exp.loadBlock</tt> caches the block file each time it's loaded, meaning that filtering multiple times doesn't take much time because as long as the block file hasn't been modified since the last time it was retrieved, it is returned from memory instead of from disk.  When dealing with many blocks this can be memory intensive.  You can clear the cache by calling <tt>clearCBToolsCache</tt>.  For some of the above examples it may be better to filter based on the parameters file, which is smaller and quicker to load than the block file.</p><pre class="codeinput"><span class="comment">% Check for advancedChoiceWorld experiments where reward size was below 3:</span>
filterFn = @(p) <span class="keyword">...</span>
  any(getOr(p, <span class="string">'rewardSize'</span>, 4) &lt; 3) &amp;&amp; <span class="keyword">...</span>
  endsWith(getOr(p, <span class="string">'expDef'</span>), <span class="string">'advancedChoiceWorld.m'</span>);
seq = filter(sequence(refs, @dat.loadParams), filterFn);
</pre><p>This will return parameter structs, but we ultimately want the block, so lets map using the expRef field:</p><pre class="codeinput">blocks = seq.map(@(p) p.expRef).map(@dat.loadBlock).toCell();
</pre><h2 id="18">Notes</h2><p>(1) One way to mitigate this is to use ALF files instead.  These files are processed versions of standard data found in the block files (e.g. new trial times, feddback times, etc.) and are quicker to load.  For more information see the analysis with ALF files guide.</p><p>(2) If you use Signals you may already be familiar with classic functions like map.  Most Rigbox functional programming tools can be found in the <a href="matlab:doc('fun')">+fun package</a>.</p><h2 id="19">Etc.</h2><p>Author: Miles Wells</p><p>v0.0.2</p><p><a href="index.html">Home</a> &gt; Analysis &gt; Block Files</p><pre class="codeinput"><span class="comment">%#ok&lt;*NASGU&gt;</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Working with block files
% Block files are the 'raw' data files produced by Experiments.  They end
% in '_block.mat'.  They are structs 


%% Loading a block file
% Block files are MAT files and can thefore be loaded from their location
% using the MATLAB |load| function, however the Data package contains a
% number of functions for making loading more convenient.  The main
% function is |dat.loadBlock|, which loads and caches a block for a given
% expRef.  For example here is how you can load the most recent experiment
% for the subject 'ALK051':
expRefs = dat.listExps('ALK051');
block = dat.loadBlock(expRefs{end});

%%%
% If there is no block file found for that experiment, an empty array is
% returned.  You can check in advance using the |dat.expExists| function.
% For more information on laoding experiments using the dat package, see
% the 'Loading experiments' section of the <./using_dat_package.html#5 Data
% Package user guide>.  This guide also has information on loading
% parameter and rig information.

%% Basic block structure
% Block files of all major Experiment types have the following fields:
%
% *expRef* - 
% The expRef for that experiment (char).
%
% *rigName* - 
% The name of the stimulus computer which the experiment ran on (char). The
% rig name itself is set in |hw.devices|, and is by default the computer's
% hostname.
%
% *startDateTime* - 
% The start datetime of the experiment as a serial date number (see
% <https://uk.mathworks.com/help/matlab/ref/datenum.html datenum>).  This
% is usually set during experiment initialization, in the Experiment's
% |init| method.
%
% *startDateTimeStr* - 
% The start datetime of the experiment as a date string in the following
% format 'dd-mmm-yyyy HH:MM:SS' (day-month-year hour:minute:second, see
% <https://uk.mathworks.com/help/matlab/ref/datestr.html datestr>).  This
% is usually set during experiment initialization, in the Experiment's
% |init| method.
%
% *endDateTime* - 
% The end datetime of the experiment as a serial date number (see
% <https://uk.mathworks.com/help/matlab/ref/datenum.html datenum>).  This
% is usually set during experiment cleanup, in the Experiment's |cleanup|
% method.
%
% *endDateTimeStr* - 
% The end datetime of the experiment as a date string in the following
% format 'dd-mmm-yyyy HH:MM:SS' (day-month-year hour:minute:second, see
% <https://uk.mathworks.com/help/matlab/ref/datestr.html datestr>).  This
% is usually set during experiment cleanuo, in the Experiments |cleanup|
% method.
%
% *duration* - 
% The duration of the experiment in seconds calculated as the difference
% between startDateTime and endDateTime, i.e. the length of time between
% initialization and cleanup.
%
% *endStatus* - 
% The status of the experiment when ended (char).  There are three options:
%
% # quit - the experiment was ended normally (i.e. the 'End' button was
% pressed in mc, or the quit key was pressed once).  In this situation the
% experiment post-delay was allowed to elapse before cleanup. 
% # abort - the experiment was ended with urgency (i.e. the 'Abort' button
% was pressed in mc, or the quit key was repeatedly pressed).  In this
% situation the post-delay is aborted and the experiment cleanup routine
% happens immediately.
% # exception - an exception was caught during the experiement and the thus
% was ended early.
%
% *exceptionMessage* - 
% The error message of the exception thrown during the experiment (char).
% If no exception occured this field is absent.

%%%
% The main experiment phases are also recorded.  These are in absolute
% seconds according to the <./clocks.html rig Clock>.  These are usually
% relative to when the runExp command was recieved by expSever.  Below is
% brief description of these fields.
%
% *experimentInitTime* - 
% The time in absolute seconds that experiment initialization occured (see
% |exp.Experiment/init|).  We enter the main experiment loop immediately
% after this.
%
% *experimentStartedTime* - 
% The time in absolute seconds that the experiment officially started.  When the
% pre-delay is set to 0 this happens immedietly after initialization.  In
% the Signals Experiment Framework this event triggers the expRef to be
% posted to the expStart event signal.
%
% *experimentEndedTime* - 
% The time in absolute seconds that the experiment officially ended, that
% is, when the quit command was received.  In the Signals Experiment
% Framework this event occurs just after the expEnd event signal updates.
%
% *experimentCleanupTime* - 
% The time in absolute seconds that we exited the main loop and began the
% cleanup routine (see |exp.Experiment/cleanup|).
%
% *stimWindowUpdateTimes* - 
% An array of times in absolute seconds when each Screen flip occured.  See
% Screen Flip? for more details.

%% SignalsExp block structure
% Signals block files can be identified by the presence of an 'expDef'
% field.  Below is an example of a typical Signals block file.
%
%     block = 
%
%       struct with fields:
% 
%                        expDef: 'C:\Users\User\Documents\Github\rigbox\signals\docs\examples\advancedChoiceWorld.m'
%         stimWindowUpdateTimes: [65×1 double]
%         stimWindowRenderTimes: [65×1 double]
%                       rigName: 'desktop-c6p85d3'
%                 startDateTime: 7.3786e+05
%              startDateTimeStr: '06-Mar-2020 13:37:46'
%                     endStatus: 'quit'
%                        expRef: '2020-03-06_1_test'
%            experimentInitTime: 1.3031e+06
%         experimentStartedTime: 1.3031e+06
%           experimentEndedTime: 1.3031e+06
%         experimentCleanupTime: 1.3031e+06
%                        events: [1×1 struct]
%                  paramsValues: [1×6 struct]
%                   paramsTimes: [1.3031e+06 1.3031e+06 1.3031e+06 1.3031e+06 1.3031e+06 1.3031e+06]
%                        inputs: [1×1 struct]
%                       outputs: [1×1 struct]
%                   endDateTime: 7.3786e+05
%                endDateTimeStr: '06-Mar-2020 13:38:03'
%                      duration: 16.3700
%
%
% Below are descriptions of all fields unique to Signals block files.  All
% fields ending in 'Times' (not 'DateTimes') are in absolute seconds.
%
% *expDef* - 
% The full path of the experiment definition function (char).
%
% *stimWindowRenderTimes* - 
% The times at which the textures finished rendering.  Subtracting these
% from the update times will give you the software window update lags.

%%%
% The other fields unique to the Signals block file contain the values and
% timestamps of various signals updates throughout the session.  Generally,
% recorded signals (a.k.a. registries) have two fields associated with
% them: one ending in 'Values' which contains an array of the values that
% signal took, and 'Times' which contains an array of equal length of the
% times in absolute seconds that the signal updated.
%
% *events* - 
% A scalar struct of values and times of the signals subassigned to the
% subscriptable events signal.  The essential events are 'expStart',
% 'expStop', 'newTrial', 'endTrial', 'repeatNum' and 'trialNum'.  Other
% fields may be present depending on the expDef.  To make future analysis
% simpler it is worth keeping the names of your event signals consistent.
%
% *inputs* - 
% A scalar struct of values and times of the input signals.  The essential
% inputs are 'wheel', 'wheelDeg' and 'wheelRad'.  If configured, there may
% also be 'lickDetector' fields (see the <./hardware_config.html#29
% hardware config guide>).  The input signals are the only recorded signals
% to update exactly once per iteration of the main experiment loop and
% therefore looking at the update times of these signals can be
% informative.
%
% *outputs* - 
% A scalar struct of values and times of the signals subassigned to the
% subscriptable outputs signal.  The fieldnames of the outputs typically
% match the ChannelNames property of the daqController object used for that
% experiment. If no outputs were triggered during the experiment this will
% be a struct with no fields.
%
% *paramsValues* -
% A non-scalar struct of all parameter values for each trial.  The length
% of this struct matches the length of block.events.newTrialTimes.  Each
% field is the name of each parameter.  Global parameters are those
% parameters for which all values are equal (e.g.
% |numel(unique([block.paramsValues.rewardKey])) == 1|).
%
% *paramsTimes* - 
% An array of all parameter update times.  Each trial all parameters update
% simultaneously.

%% ChoiceWorld block structure
% ChoiceWorld block files can be identified by the expType field.  Below is
% an example of a typical ChoiceWorld block file.
%
%     block = 
% 
%       struct with fields:
% 
%                          expType: 'ChoiceWorld'
%                            trial: [1×202 struct]
%            stimWindowUpdateTimes: [8885×1 double]
%             stimWindowUpdateLags: [8885×1 double]
%                    startDateTime: 7.3686e+05
%                 startDateTimeStr: '14-Jun-2017 14:39:04'
%                       parameters: [1×1 struct]
%                        endStatus: 'quit'
%             rewardDeliveredSizes: [162×2 double]
%              rewardDeliveryTimes: [1×162 double]
%                          rigName: 'zredone'
%                           expRef: '2017-06-14_2_ALK051'
%               experimentInitTime: 0.2818
%            experimentStartedTime: 0.3033
%              experimentEndedTime: 1.6009e+03
%            experimentCleanupTime: 1.6009e+03
%                      endDateTime: 7.3686e+05
%                   endDateTimeStr: '14-Jun-2017 15:05:45'
%               numCompletedTrials: 201
%                         duration: 1.6007e+03
%             inputSensorPositions: [476057×1 double]
%         inputSensorPositionTimes: [476057×1 double]
%                  inputSensorGain: 2.0309
%                       lickCounts: []
%                   lickCountTimes: []
%
%
% Below are descriptions of all fields unique to ChoiceWorld block files.
% The blocks of other experiment types follow a broadly similar structure.
% All fields ending in 'Times' (not 'DateTimes') are in absolute seconds.
%
% *expType* - 
% The experiment type (char), i.e. the name of the experiment chosen from
% the 'type' dropdown in mc.  Strictly speaking this is the value of the
% 'type' parameter.  For ChoiceWorld experiments this is obviously
% 'ChoiceWorld'.
%
% *inputSensorGain* - 
% The gain of the input with respect to the stimulus (double).  This is a
% multiplier with the units of visual pixles per rotary encoder 'tick'.  In
% ChoiceWorld this is set by the |calibrateInputGain| method of
% |exp.ChoiceWorld|.  It is calculated using the input sensor's
% 'MillimetersFactor' property, the 'visWheelGain' parameter and the visual
% pixel density determined by by the stimViewingModel.
%
% *inputSensorPositions* - 
% An array of absolute values of the input sensor (i.e.
% '<./hardware_config.html#27 mouseInput>' field of the rig object).  
%
% *inputSensorPositionTimes* - 
% The update times in absolute seconds of the input sensor.  The input
% sensor is the only recorded event to update exactly once per iteration of
% the main experiment loop and can therefore be used to determine the
% performance of the experiment.
%
% *lickCounts* - 
% The values recorded from the 'lickDetector' field of the rig object (see
% the <./hardware_config.html#29 hardware config guide>).  If no
% lickDetector is present this is just an empty double.
%
% *lickCountTimes* - 
% The update times in absolute seconds of the lickDetector sensor.  If no
% lickDetector is present this is just an empty double.
%
% *numCompletedTrials* - 
% The total number of completed trials.  The last trial is often incomplete
% if the experiment is ended by the experimenter.  Therefore this value can
% be used to trim the 'trials' struct array.
%
% *parameters* - 
% A copy of the <./glossary.html global parameters> used for this
% experiment.  See the <./Parameters.html Parameters guide> for more info.
%
% *rewardDeliveredSizes* - 
% An array of reward delivery sizes in microlitres.  Related to the
% 'rewardVolume' parameter.
%
% *rewardDeliveryTimes* - 
% An array of reward delivery times in absolute seconds.  That is, the
% times at which the command was sent to the hw.DaqController object.  
%
% *stimWindowUpdateLags* - 
% An array of times in seconds between the stimulus window being
% invalidated and the buffer getting flipped to the screen.
%
% *trial* - 
% A nonscalar struct of times and outcomes for each trial.  Its length is
% equal to or one greater than the value of block.numCompleteTrials.  All
% trial phases and events have fields containing the times in absolute
% seconds that they occured.  For example 'feebackNegativeStartedTime' and
% 'inputThresholdCrossedTime'.  The IDs of some of these events are also
% included (e.g. 'responseMadeID' and 'inputThresholdCrossedID').  The ID
% value maps for these two fields are defined by the 'responseForThreshold'
% and 'responseForNoGo' parameter fields.  The 'feedbackType' is -1 for
% negative and 1 for positive.  Some fields have empty values for some
% trials indicating that this event didn't occur during that trial (e.g.
% 'positiveFeedbackStartedTime' is empty for incorrect trials).
%
% There is also a 'condition' field whose value is a struct of all
% <./glossary.html conditional parameter> values for that trial:
%
%     block.trial(1).condition
% 
%     ans = 
% 
%       struct with fields:
% 
%                 rewardVolume: [2×1 double]
%               visCueContrast: [2×1 double]
%          feedbackForResponse: [3×1 double]
%         repeatIncorrectTrial: 0
%                    repeatNum: 1
%

%% Processing multiple blocks
% Precessing multiple block can be tricky as some experiments may not have
% a block file associated with them, may be of a different type and may
% have very different parameters(1).  There are a few functions availiable
% in Rigbox for filtering block files, which can make the pre-processing
% stage simpler.  Below are some ways to filter and load blocks using
% functional programming tools(2).
%
% List the expRefs for 'subject'.  NB: dat.listExps can also deal is cell
% arrays of subjects. Filter out all experiments that don't have a block
% file.
blockExists = @(r) file.exists(dat.expFilePath(r, 'block', 'master'));
refs = fun.filter(blockExists, dat.listExps(subject));

%%%
% Create a sequence from this list and specify a loader function.  The
% loader function is only called when required, avoiding premature and
% unnecessary loading.  This is also useful when searching for just one
% specific block.  For ChoiceWorld we can filter blocks using
% |dat.loadBlock(ref, 'ChoiceWorld')|.  Below we show how to filter by
% expDef name.
seq = sequence(refs, @dat.loadBlock);

%%%
% Reverse the sequence so that we search most recent experiments first, and
% filter using a function that checks the expDef field.  Note that the
% filter function must return true or false, and gets the output of the
% loader function (in this case the block file, not the ref) as its input.
expDefType = @(b) endsWith(b.expDef, 'advancedChoiceWorld.m');
seq = seq.reverse.filter(expDefType); 
b = seq.first; % Return the most recent advancedChoiceWorld block file

%%%
% We can return all blocks as a cell array with the following command:
blocks = toCell(seq);

%%%
% If we want only the events structures, we can take them using |map|.  
events = catStructs(seq.map(@(b) b.events).toCell); % Return as array of structs

%%%
% Sometimes those last incomplete trials can be a pain.  Let's trim them
% before returning using structfun, which applies a function to every
% field of a struct, and iff, which is like an if-else statement as a
% one-liner.

% If event one greater than endTrialTimes, trim to the length of
% endTrialTimes, otherwise return the array as normal.
trimTrials = @(evts) structfun(@(e) ...
  iff(length(e) == length(evts.endTrialTimes) + 1, ... 
  @() e(1:numel(evts.endTrialTimes)), e), evts, 'uni', 0);
events = seq.map(@(b) b.events).map(trimTrials).toCell; % Return as cell array

%%%
% Say we only want blocks where a certain event was recorded, simply filter
% by that fieldname.  Below is a sophisticated example where we define an
% anonymous function that searches for a given event.  That way we can
% apply this filter for multiple events:
present = @(e) @(b) isfield(b.events.(e));
seq = seq.filter(present('prefDecrease'));

%%%
% Say we want to return the events struct for the first block where the
% parameter 'rewardSize' was less than 3.  We use the function |getOr| to
% ensure that we don't get an error for blocks that don't have this
% parameter.
lowRwd = @(b) getOr(b.paramsValues, 'rewardSize', 4) < 3;
events = seq.filter(lowRwd).map(@(b) b.events).first;

%%%
% |exp.loadBlock| caches the block file each time it's loaded, meaning that
% filtering multiple times doesn't take much time because as long as the block
% file hasn't been modified since the last time it was retrieved, it is
% returned from memory instead of from disk.  When dealing with many blocks
% this can be memory intensive.  You can clear the cache by calling
% |clearCBToolsCache|.  For some of the above examples it may be better to
% filter based on the parameters file, which is smaller and quicker to
% load than the block file.

% Check for advancedChoiceWorld experiments where reward size was below 3:
filterFn = @(p) ...
  any(getOr(p, 'rewardSize', 4) < 3) && ...
  endsWith(getOr(p, 'expDef'), 'advancedChoiceWorld.m');
seq = filter(sequence(refs, @dat.loadParams), filterFn);

%%%
% This will return parameter structs, but we ultimately want the block, so
% lets map using the expRef field:
blocks = seq.map(@(p) p.expRef).map(@dat.loadBlock).toCell();

%% Notes
% (1) One way to mitigate this is to use ALF files instead.  These files are
% processed versions of standard data found in the block files (e.g. new
% trial times, feddback times, etc.) and are quicker to load.  For more
% information see the analysis with ALF files guide.
%
% (2) If you use Signals you may already be familiar with classic functions
% like map.  Most Rigbox functional programming tools can be found in the
% <matlab:doc('fun') +fun package>.

%% Etc.
% Author: Miles Wells
%
% v0.0.2
%
% <index.html Home> > Analysis > Block Files

%#ok<*NASGU>
##### SOURCE END #####
--></body></html>